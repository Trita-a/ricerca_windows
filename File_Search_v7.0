import os
import shutil
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from tkinter import filedialog, messagebox, BooleanVar, StringVar, IntVar
import threading
import queue
from datetime import datetime
import getpass
import zipfile
from ttkbootstrap.dialogs import Querybox
import traceback
import time
import concurrent.futures
import mimetypes
import signal

# Dizionario per tracciare il supporto alle librerie
file_format_support = {
    "docx": False,
    "pdf": False,
    "pptx": False,
    "excel": False,
    "odt": False,
    "rtf": False
}

# Elenco di librerie da installare se mancanti
missing_libraries = []

# Importazione di librerie opzionali con gestione degli errori
try:
    import docx
    file_format_support["docx"] = True
    print("Supporto Word (.docx) attivato")
except ImportError:
    missing_libraries.append("python-docx")
    print("Supporto Word (.docx) non disponibile")

try:
    import PyPDF2
    file_format_support["pdf"] = True
    print("Supporto PDF attivato")
except ImportError:
    missing_libraries.append("PyPDF2")
    print("Supporto PDF non disponibile")

try:
    import pptx
    file_format_support["pptx"] = True
    print("Supporto PowerPoint attivato")
except ImportError:
    missing_libraries.append("python-pptx")
    print("Supporto PowerPoint non disponibile")

try:
    import openpyxl
    file_format_support["excel"] = True
    print("Supporto Excel attivato")
except ImportError:
    missing_libraries.append("openpyxl")
    print("Supporto Excel non disponibile")

try:
    from striprtf.striprtf import rtf_to_text
    file_format_support["rtf"] = True
    print("Supporto RTF attivato")
except ImportError:
    missing_libraries.append("striprtf")
    print("Supporto RTF non disponibile")

try:
    import odfdo
    file_format_support["odt"] = True
    print("Supporto ODT attivato (libreria odfdo)")
except ImportError:
    try:
        from odf import opendocument, text, teletype
        file_format_support["odt"] = True
        print("Supporto ODT attivato (libreria odf)")
    except ImportError:
        missing_libraries.append("odfdo")
        print("Supporto ODT non disponibile")

class FileSearchApp:
    def __init__(self, root):
        self.root = root
        self.root.title("File Search Tool.. Nucleo Perugia")
        self.root.geometry("1300x850")
        
        # Inizializza le variabili per data/ora e utente
        self.datetime_var = StringVar()
        self.user_var = StringVar(value=getpass.getuser())
        
        # Variabili
        self.search_content = BooleanVar(value=False)
        self.search_path = StringVar()
        self.keywords = StringVar()
        self.search_results = []
        self.search_files = BooleanVar(value=True)
        self.search_folders = BooleanVar(value=True)
        self.ignore_hidden = BooleanVar(value=True)
        self.is_searching = False
        self.progress_queue = queue.Queue()
        self.search_executor = None
        
        # Variabili aggiuntive per i miglioramenti
        self.stop_search = False
        self.max_depth = 0  # 0 = illimitato
        self.last_search_params = {}
        self.search_history = []
        self.advanced_filters = {
            "size_min": 0,
            "size_max": 0,
            "date_min": None,
            "date_max": None,
            "extensions": []
        }
        
        # Variabili per limiti di tempo e altre ottimizzazioni
        self.timeout_enabled = BooleanVar(value=False)
        self.timeout_seconds = IntVar(value=60)  # Default 60 secondi
        self.max_files_to_check = IntVar(value=10000)  # Limite numero di file da controllare
        self.max_results = IntVar(value=1000)  # Limite numero di risultati
        self.chunk_size = 8192  # Grandezza del chunk per la lettura dei file
        self.max_file_size_mb = IntVar(value=100)  # Dimensione massima file da analizzare (in MB)
        self.worker_threads = IntVar(value=4)  # Numero di worker threads per elaborazione parallela
        self.use_indexing = BooleanVar(value=True)  # Usa indicizzazione per velocizzare ricerche future
        self.search_index = {}  # Dizionario per indicizzare file e contenuti
        
        # Info utente e datetime
        self.current_user = getpass.getuser()
        self.datetime_var = StringVar()
        self.update_datetime()
        self.create_widgets()

        # Verifica le librerie e mostra notifica se necessario
        self.check_and_notify_missing_libraries()
        self.debug_mode = True

    # Gestione CTRL+C e chiusura
    def handle_interrupt(sig, frame):
        if self.is_searching:
            self.stop_search_process()
        else:
            self.root.quit()

    signal.signal(signal.SIGINT, handle_interrupt)

    def log_debug(self, message):
        """Funzione per logging, stampa solo quando debug_mode è True"""
        if self.debug_mode:
            print(f"[DEBUG] {message}")

    def check_and_notify_missing_libraries(self):
        """Verifica e notifica l'utente di eventuali librerie mancanti"""
        missing = []
        
        if not file_format_support["docx"]:
            missing.append("python-docx (per file Word)")
        if not file_format_support["pdf"]: 
            missing.append("PyPDF2 (per file PDF)")
        if not file_format_support["pptx"]:
            missing.append("python-pptx (per file PowerPoint)")
        if not file_format_support["excel"]:
            missing.append("openpyxl (per file Excel)")
        if not file_format_support["rtf"]:
            missing.append("striprtf (per file RTF)")
        if not file_format_support["odt"]:
            missing.append("odfdo (per file OpenDocument)")
        
        if missing:
            message = "Alcune funzionalità di ricerca nei contenuti sono disabilitate.\n\n"
            message += "Per abilitare il supporto completo ai vari formati di file, installa le seguenti librerie:\n\n"
            
            for lib in missing:
                message += f"- {lib}\n"
            
            message += "\nPuoi installarle con il comando:\n"
            message += "pip install " + " ".join([lib.split(" ")[0] for lib in missing])
            
            # Mostra la notifica dopo un breve ritardo per permettere all'UI di caricarsi
            self.root.after(1000, lambda: messagebox.showinfo("Librerie opzionali mancanti", message))

    def update_datetime(self):
        current_time = datetime.now().strftime('%d-%m-%Y %H:%M:%S')
        self.datetime_var.set(f"Data: {current_time} | Utente: {self.current_user}")
        self.root.after(1000, self.update_datetime)

    def browse_directory(self):
        directory = filedialog.askdirectory()
        if directory:
            self.search_path.set(directory)
            
    def start_search(self):
        # Pulisci risultati precedenti
        for item in self.results_list.get_children():
            self.results_list.delete(item)
        
        if not self.search_path.get() or not self.keywords.get():
            messagebox.showerror("Errore", "Inserisci directory e parole chiave")
            return
        
        # Reset per la nuova ricerca
        self.stop_search = False
        self.stop_button["state"] = "normal"
        
        # Aggiorna l'orario di avvio e resetta l'orario di fine
        current_time = datetime.now().strftime('%H:%M')
        self.start_time_label.config(text=current_time)
        self.end_time_label.config(text="--:--")

        # Salva i parametri di ricerca
        self.last_search_params = {
            "path": self.search_path.get(),
            "keywords": self.keywords.get(),
            "search_files": self.search_files.get(),
            "search_folders": self.search_folders.get(),
            "search_content": self.search_content.get()
        }
        
        # Aggiungi alla cronologia di ricerca se non già presente
        if self.keywords.get() and self.keywords.get() not in [h["keywords"] for h in self.search_history]:
            self.search_history.append(self.last_search_params.copy())
            if len(self.search_history) > 10:  # Mantieni solo le ultime 10 ricerche
                self.search_history.pop(0)
        
        self.is_searching = True
        self.search_button["state"] = "disabled"
        self.progress_bar["value"] = 0
        self.status_label["text"] = "Ricerca in corso..."
        
        # Aggiorna il valore della profondità massima
        try:
            self.max_depth = int(self.depth_spinbox.get())
        except ValueError:
            self.max_depth = 0  # Valore predefinito se non valido
        
        # Ottieni le parole chiave di ricerca
        search_terms = [term.strip() for term in self.keywords.get().split(',') if term.strip()]
            
        # Avvia la ricerca in un thread separato
        self.search_results = []  # Resetta i risultati
        search_thread = threading.Thread(target=self._search_thread, 
                                        args=(self.search_path.get(), search_terms, self.search_content.get()))
        search_thread.daemon = True
        search_thread.start()
        
        # Avvia l'aggiornamento della progress bar
        self.update_progress()

    def update_progress(self):
        if self.is_searching:
            try:
                while True:
                    progress_type, value = self.progress_queue.get_nowait()
                    if progress_type == "progress":
                        self.progress_bar["value"] = value
                    elif progress_type == "status":
                        self.status_label["text"] = value
                    elif progress_type == "complete":
                        self.is_searching = False
                        self.search_button["state"] = "normal"
                        self.stop_button["state"] = "disabled"
                        
                        # Aggiorna la lista dei risultati
                        self.update_results_list()
                        
                        if len(self.search_results) == 0:
                            self.status_label["text"] = "Nessun file trovato per la ricerca effettuata"
                            self.root.after(100, lambda: messagebox.showinfo("Ricerca completata", "Nessun file trovato per la ricerca effettuata"))
                        else:
                            self.status_label["text"] = f"Ricerca completata! Trovati {len(self.search_results)} risultati."
                        
                        self.progress_bar["value"] = 100
                        current_time = datetime.now().strftime('%H:%M')
                        self.end_time_label.config(text=current_time)
                        return
                    elif progress_type == "error":
                        self.is_searching = False
                        self.search_button["state"] = "normal"
                        self.stop_button["state"] = "disabled"
                        current_time = datetime.now().strftime('%H:%M')
                        self.end_time_label.config(text=current_time)
                        messagebox.showerror("Errore", value)
                        return
                    elif progress_type == "timeout":
                        self.is_searching = False
                        self.search_button["state"] = "normal"
                        self.stop_button["state"] = "disabled"
                        self.update_results_list()  # Mostra i risultati trovati fino a quel momento
                        current_time = datetime.now().strftime('%H:%M')
                        self.end_time_label.config(text=current_time)
                        messagebox.showinfo("Timeout", "La ricerca è stata interrotta per timeout. Verranno mostrati i risultati parziali trovati.")
                        return
            except queue.Empty:
                pass
                    
            self.root.after(100, self.update_progress)
            
    def stop_search_process(self):
        """Ferma il processo di ricerca in corso"""
        self.stop_search = True
        self.status_label["text"] = "Interrompendo la ricerca..."
        current_time = datetime.now().strftime('%H:%M')
        self.end_time_label.config(text=current_time)
        
        # Chiudi l'executor se esiste
        if self.search_executor:
            self.search_executor.shutdown(wait=False, cancel_futures=True)
        
        # Aggiorna l'orario di fine quando la ricerca viene interrotta
        self.search_button["state"] = "normal"
        self.stop_button["state"] = "disabled"

    def show_advanced_filters_dialog(self):
        """Mostra la finestra di dialogo per i filtri di ricerca avanzati"""
        dialog = ttk.Toplevel(self.root)
        dialog.title("Filtri avanzati")
        dialog.geometry("500x350")
        dialog.transient(self.root)
        dialog.grab_set()
        
        # Filtri dimensione
        size_frame = ttk.LabelFrame(dialog, text="Dimensione file")
        size_frame.pack(fill=X, padx=10, pady=5)
        
        ttk.Label(size_frame, text="Min (KB):").grid(row=0, column=0, padx=5, pady=5)
        min_size = ttk.Entry(size_frame, width=10)
        min_size.grid(row=0, column=1, padx=5, pady=5)
        min_size.insert(0, str(self.advanced_filters["size_min"] // 1024))
        
        ttk.Label(size_frame, text="Max (KB):").grid(row=0, column=2, padx=5, pady=5)
        max_size = ttk.Entry(size_frame, width=10)
        max_size.grid(row=0, column=3, padx=5, pady=5)
        max_size.insert(0, str(self.advanced_filters["size_max"] // 1024 if self.advanced_filters["size_max"] else 0))
        
        # Filtri data - FORMAT DD-MM-YYYY
        date_frame = ttk.LabelFrame(dialog, text="Data modifica (DD-MM-YYYY)")
        date_frame.pack(fill=X, padx=10, pady=5)
        
        ttk.Label(date_frame, text="Da:").grid(row=0, column=0, padx=5, pady=5)
        min_date = ttk.DateEntry(date_frame, dateformat="%d-%m-%Y")
        min_date.grid(row=0, column=1, padx=5, pady=5)
        
        ttk.Label(date_frame, text="A:").grid(row=0, column=2, padx=5, pady=5)
        max_date = ttk.DateEntry(date_frame, dateformat="%d-%m-%Y")
        max_date.grid(row=0, column=3, padx=5, pady=5)
        
        # Prepopola le date se disponibili
        if self.advanced_filters["date_min"]:
            min_date.entry.delete(0, "end")
            min_date.entry.insert(0, self.advanced_filters["date_min"])
                
        if self.advanced_filters["date_max"]:
            max_date.entry.delete(0, "end")
            max_date.entry.insert(0, self.advanced_filters["date_max"])
        
        # Filtri estensione
        ext_frame = ttk.LabelFrame(dialog, text="Estensioni file (separate da virgola)")
        ext_frame.pack(fill=X, padx=10, pady=5)
        example_label = ttk.Label(ext_frame, text="Inserisci una o più estensioni da ricercare. Esempio: .pdf, .dot", 
                       font=("", 8), foreground="gray")
        example_label.pack(anchor="w", padx=5)
        
        extensions = ttk.Entry(ext_frame)
        extensions.pack(fill=X, padx=5, pady=5)
        if self.advanced_filters["extensions"]:
            extensions.insert(0, ", ".join(self.advanced_filters["extensions"]))
        
        # Aggiungiamo un frame di debug per vedere i filtri correnti
        debug_frame = ttk.LabelFrame(dialog, text="Debug - Stato filtri correnti")
        debug_frame.pack(fill=X, padx=10, pady=5)
        
        debug_text = ttk.Text(debug_frame, height=3, width=50)
        debug_text.pack(fill=X, padx=5, pady=5)
        debug_text.insert("1.0", f"Data min: {self.advanced_filters['date_min']}\n")
        debug_text.insert("2.0", f"Data max: {self.advanced_filters['date_max']}\n")
        debug_text.insert("3.0", f"Extensions: {self.advanced_filters['extensions']}")
        debug_text.config(state="disabled")
        
        # Pulsante Salva
        def save_filters():
            try:
                # Analizza i filtri di dimensione
                min_kb = int(min_size.get() or 0)
                max_kb = int(max_size.get() or 0)
                self.advanced_filters["size_min"] = min_kb * 1024
                self.advanced_filters["size_max"] = max_kb * 1024
                
                # Ottieni le date nel formato DD-MM-YYYY
                min_date_value = min_date.entry.get().strip()
                max_date_value = max_date.entry.get().strip()
                
                print(f"DEBUG - Date inserite: min={min_date_value}, max={max_date_value}")
                
                # Validazione date
                if min_date_value:
                    try:
                        # Verifica formato corretto
                        datetime.strptime(min_date_value, "%d-%m-%Y")
                    except ValueError:
                        messagebox.showerror("Errore", "Formato data minima non valido. Usa DD-MM-YYYY")
                        return
                
                if max_date_value:
                    try:
                        # Verifica formato corretto
                        datetime.strptime(max_date_value, "%d-%m-%Y")
                    except ValueError:
                        messagebox.showerror("Errore", "Formato data massima non valido. Usa DD-MM-YYYY")
                        return
                
                # Verifica che la data minima non sia successiva alla data massima
                if min_date_value and max_date_value:
                    min_date_obj = datetime.strptime(min_date_value, "%d-%m-%Y")
                    max_date_obj = datetime.strptime(max_date_value, "%d-%m-%Y")
                    
                    if min_date_obj > max_date_obj:
                        messagebox.showerror("Errore", 
                                            "La data di inizio non può essere successiva alla data di fine")
                        return
                
                # Salva le date validate
                self.advanced_filters["date_min"] = min_date_value
                self.advanced_filters["date_max"] = max_date_value
                
                # Analizza le estensioni
                exts = [e.strip() for e in extensions.get().split(",") if e.strip()]
                self.advanced_filters["extensions"] = [f".{e.lstrip('.')}" for e in exts]
                
                print(f"Filtri salvati: {self.advanced_filters}")  # Debug info
                dialog.destroy()
                
            except ValueError:
                messagebox.showerror("Errore", "Inserisci valori numerici validi per le dimensioni")
        
        ttk.Button(dialog, text="Salva", command=save_filters).pack(pady=10)
        ttk.Button(dialog, text="Annulla", command=dialog.destroy).pack(pady=5)

        dialog.update_idletasks()  # Aggiorna la finestra per ottenere le dimensioni corrette
        width = dialog.winfo_width()
        height = dialog.winfo_height()
        x = (dialog.winfo_screenwidth() // 2) - (width // 2)
        y = (dialog.winfo_screenheight() // 2) - (height // 2)
        dialog.geometry(f"{width}x{height}+{x}+{y}")
        
        # Imposta una dimensione minima per la finestra
        dialog.minsize(500, 400)

    def create_widgets(self):
        # Frame principale che conterrà tutto tranne la barra di stato
        main_container = ttk.Frame(self.root)
        main_container.pack(fill=BOTH, expand=YES)
        
        # Frame principale per il contenuto
        main_frame = ttk.Frame(main_container, padding="10")
        main_frame.pack(fill=BOTH, expand=YES)
        
        # Aggiungi selezione tema
        theme_frame = ttk.Frame(main_frame)
        theme_frame.pack(fill=X, pady=5)
        
        ttk.Label(theme_frame, text="Tema:").pack(side=LEFT, padx=5)
        themes = ttk.Style().theme_names()
        theme_combobox = ttk.Combobox(theme_frame, values=themes, width=15)
        theme_combobox.pack(side=LEFT, padx=5)
        theme_combobox.current(themes.index("darkly"))
        theme_combobox.bind("<<ComboboxSelected>>", lambda e: [ttk.Style().theme_use(theme_combobox.get()),self.update_theme_colors()])
        
        # Sezione selezione directory
        path_frame = ttk.LabelFrame(main_frame, text="Directory di ricerca", padding="5")
        path_frame.pack(fill=X, pady=5)
       
        self.path_entry = ttk.Entry(path_frame, textvariable=self.search_path)
        example_label = ttk.Label(path_frame, text="Seleziona la directory per effettuare la ricerca dei file", 
                       font=("", 8), foreground="gray")
        example_label.pack(anchor="w", padx=5)
        self.path_entry.pack(side=LEFT, fill=X, expand=YES, padx=5)
        
        ttk.Button(path_frame, text="Sfoglia", command=self.browse_directory).pack(side=LEFT, padx=5)
        
        # Sezione keywords
        keyword_frame = ttk.LabelFrame(main_frame, text="Parole chiave", padding="5")
        keyword_frame.pack(fill=X, pady=5)

        # Aggiungi il tooltip sulla casella delle parole chiave
        example_label = ttk.Label(keyword_frame, text="Per la ricerca di più parole usa la virgola. Esempio: documento, fattura, contratto", 
                       font=("", 8), foreground="gray")
        example_label.pack(anchor="w", padx=5)

        # Crea l'entry delle parole chiave e salvala come attributo dell'istanza
        self.keyword_entry = ttk.Entry(keyword_frame, textvariable=self.keywords)
        self.keyword_entry.pack(fill=X, padx=5)
           
        # Opzioni di ricerca
        options_frame = ttk.LabelFrame(main_frame, text="Opzioni di ricerca", padding="5")
        options_frame.pack(fill=X, pady=5)
        example_label = ttk.Label(options_frame, text="Seleziona una o più opzioni per la ricerca", 
                       font=("", 8), foreground="gray")
        example_label.pack(anchor="w", padx=5)
        ttk.Checkbutton(options_frame, text="Cerca file", variable=self.search_files).pack(side=LEFT, padx=5)
        ttk.Checkbutton(options_frame, text="Cerca cartelle", variable=self.search_folders).pack(side=LEFT, padx=5)
        
        # Checkbox "Cerca nei contenuti" 
        content_checkbox = ttk.Checkbutton(options_frame, text="Cerca nei contenuti", 
                                  variable=self.search_content, 
                                  command=self.warn_content_search)
        content_checkbox.pack(side=LEFT, padx=5)
        self.create_tooltip(content_checkbox, "Cerca le parole chiave anche all'interno dei file di testo")

        # Aggiungi un'opzione per limitare la profondità di ricerca
        depth_frame = ttk.Frame(options_frame)
        depth_frame.pack(side=RIGHT, padx=5)
        
        ttk.Label(depth_frame, text="Profondità max:").pack(side=LEFT)
        
        self.depth_spinbox = ttk.Spinbox(depth_frame, from_=0, to=10, width=3)
        self.depth_spinbox.pack(side=LEFT)
        self.depth_spinbox.set("0")  # 0 significa illimitato
        self.create_tooltip(self.depth_spinbox, "Limita la profondità di ricerca nelle sottocartelle.\n0 = Illimitato.\n1 = Cerca solo nella cartella selezionata e nelle sue sottocartelle immediate.\n10 = Cerca fino a 10 livelli di sottocartelle.")
        
        # Aggiungi pulsante per filtri avanzati
        ttk.Button(options_frame, text="Filtri avanzati", 
                  command=self.show_advanced_filters_dialog).pack(side=RIGHT, padx=5)
        
        # Frame per le opzioni di performance e timeout
        perf_frame = ttk.LabelFrame(main_frame, text="Opzioni di Performance", padding="5")
        perf_frame.pack(fill=X, pady=5)
        
        # Opzione timeout
        timeout_frame = ttk.Frame(perf_frame)
        timeout_frame.pack(side=LEFT, padx=10, fill=X, expand=True)
        
        timeout_cb = ttk.Checkbutton(timeout_frame, text="Timeout ricerca", variable=self.timeout_enabled)
        timeout_cb.pack(side=LEFT)
        
        ttk.Label(timeout_frame, text="Secondi:").pack(side=LEFT, padx=(10, 5))
        timeout_spinbox = ttk.Spinbox(timeout_frame, from_=10, to=600, width=4, 
                                     textvariable=self.timeout_seconds)
        timeout_spinbox.pack(side=LEFT)
        self.create_tooltip(timeout_cb, "Interrompe automaticamente la ricerca dopo il tempo specificato")
        
        # Opzione thread paralleli
        threads_frame = ttk.Frame(perf_frame)
        threads_frame.pack(side=LEFT, padx=10)
        
        ttk.Label(threads_frame, text="Thread:").pack(side=LEFT)
        threads_spinbox = ttk.Spinbox(threads_frame, from_=1, to=16, width=2, 
                                     textvariable=self.worker_threads)
        threads_spinbox.pack(side=LEFT, padx=5)
        self.create_tooltip(threads_frame, "Numero di thread paralleli per la ricerca nei contenuti")
        
        # Opzione dimensione massima file
        filesize_frame = ttk.Frame(perf_frame)
        filesize_frame.pack(side=LEFT, padx=10)
        
        ttk.Label(filesize_frame, text="Max file MB:").pack(side=LEFT)
        max_size_spinbox = ttk.Spinbox(filesize_frame, from_=1, to=1000, width=4,
                                     textvariable=self.max_file_size_mb)
        max_size_spinbox.pack(side=LEFT, padx=5)
        self.create_tooltip(filesize_frame, "Dimensione massima dei file da analizzare (in MB)")
        
        # Opzione numero massimo di risultati
        max_results_frame = ttk.Frame(perf_frame)
        max_results_frame.pack(side=LEFT, padx=10)
        
        ttk.Label(max_results_frame, text="Max risultati:").pack(side=LEFT)
        max_results_spinbox = ttk.Spinbox(max_results_frame, from_=100, to=100000, width=6,
                                         textvariable=self.max_results)
        max_results_spinbox.pack(side=LEFT, padx=5)
        self.create_tooltip(max_results_frame, "Numero massimo di risultati da mostrare")
        
        # Opzione indicizzazione
        indexing_frame = ttk.Frame(perf_frame)
        indexing_frame.pack(side=LEFT, padx=10)
        
        indexing_cb = ttk.Checkbutton(indexing_frame, text="Indicizzazione", 
                                     variable=self.use_indexing)
        indexing_cb.pack(side=LEFT)
        self.create_tooltip(indexing_cb, "Memorizza i risultati per velocizzare ricerche future")
        
        # Frame per i pulsanti di ricerca
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(pady=5)
        
        # Pulsante di ricerca
        self.search_button = ttk.Button(button_frame, text="Cerca", 
                                      command=self.start_search, 
                                      style="primary.TButton")
        self.search_button.pack(side=LEFT, padx=5)
        
        # Pulsante per interrompere la ricerca
        self.stop_button = ttk.Button(button_frame, 
                                     text="Interrompi ricerca",
                                     command=self.stop_search_process,
                                     style="danger.TButton",
                                     state="disabled")
        self.stop_button.pack(side=LEFT, padx=5)
        
        # Pulsante per pulire i campi di ricerca
        ttk.Button(button_frame, 
                  text="Pulisci campi", 
                  command=lambda: [self.search_path.set(""), self.keywords.set("")],
                  style="secondary.Outline.TButton").pack(side=LEFT, padx=5)
        
        # Frame separatore per migliorare la visualizzazione
        separator = ttk.Separator(main_frame, orient='horizontal')
        separator.pack(fill=X, pady=10)
        
        # Nuovo frame per le etichette di tempo con stile migliorato
        time_frame = ttk.LabelFrame(main_frame, text="Informazioni temporali", padding="5")
        time_frame.pack(fill=X, pady=(0, 10))
        
        # Container interno per le etichette
        time_labels_container = ttk.Frame(time_frame)
        time_labels_container.pack(expand=True)
        
        # Frame per l'orario di avvio
        start_time_frame = ttk.Frame(time_labels_container)
        start_time_frame.pack(side=LEFT, padx=20)
        
        ttk.Label(start_time_frame, 
                text="Avvio ricerca:", 
                font=("", 9)).pack(side=LEFT)
        
        self.start_time_label = ttk.Label(start_time_frame, 
                                        text="--:--", 
                                        font=("", 9, "bold"))
        self.start_time_label.pack(side=LEFT, padx=(5, 0))
        
        # Separatore verticale tra le etichette
        ttk.Separator(time_labels_container, orient='vertical').pack(side=LEFT, fill=Y, padx=15)
        
        # Frame per l'orario di fine
        end_time_frame = ttk.Frame(time_labels_container)
        end_time_frame.pack(side=LEFT, padx=20)
        
        ttk.Label(end_time_frame, 
                text="Fine ricerca:", 
                font=("", 9)).pack(side=LEFT)
        
        self.end_time_label = ttk.Label(end_time_frame, 
                                    text="--:--", 
                                    font=("", 9, "bold"))
        self.end_time_label.pack(side=LEFT, padx=(5, 0))
               
        # Area risultati
        results_frame = ttk.LabelFrame(main_frame, text="Risultati", padding="5")
        results_frame.pack(fill=BOTH, expand=YES, pady=5)

        # Frame per i pulsanti di azione
        action_buttons_frame = ttk.Frame(results_frame)
        action_buttons_frame.pack(fill=X, pady=(0, 5))
        
        # Pulsanti per la selezione
        ttk.Button(action_buttons_frame, text="Seleziona tutto", 
                  command=self.select_all).pack(side=LEFT, padx=2)
        ttk.Button(action_buttons_frame, text="Deseleziona tutto", 
                  command=self.deselect_all).pack(side=LEFT, padx=2)
        ttk.Button(action_buttons_frame, text="Inverti selezione", 
                  command=self.invert_selection).pack(side=LEFT, padx=2)
        
        # Scrollbar per la lista risultati
        scrollbar = ttk.Scrollbar(results_frame)
        scrollbar.pack(side=RIGHT, fill=Y)
        
        # Configura la Treeview
        self.results_list = ttk.Treeview(results_frame, selectmode="extended",
                            columns=("type", "author", "size", "modified", "created", "path"),
                            show="headings")

        # Imposta le colonne con larghezze appropriate e centraggio
        self.results_list.column("type", width=150, anchor="center")
        self.results_list.column("author", width=100, anchor="w")
        self.results_list.column("size", width=100, anchor="center")
        self.results_list.column("modified", width=140, anchor="center")
        self.results_list.column("created", width=140, anchor="center")
        self.results_list.column("path", width=400, anchor="w")
        
        # Imposta le intestazioni
        self.results_list.heading("type", text="Tipo File")
        self.results_list.heading("author", text="Nome File")
        self.results_list.heading("size", text="Dimensione")
        self.results_list.heading("modified", text="Modificato")
        self.results_list.heading("created", text="Creato")
        self.results_list.heading("path", text="Percorso")

        # Impostazione delle larghezze colonne
        self.results_list.column("type", width=80)
        self.results_list.column("author", width=250)
        self.results_list.column("size", width=80)
        self.results_list.column("modified", width=80)
        self.results_list.column("created", width=80)
        self.results_list.column("path", width=500)
        
        self.results_list.pack(fill=BOTH, expand=YES)
        
        scrollbar.config(command=self.results_list.yview)
        self.results_list.config(yscrollcommand=scrollbar.set)
        
        # Frame per i pulsanti di azione principali
        main_buttons_frame = ttk.Frame(main_frame)
        main_buttons_frame.pack(fill=X, pady=5)
        
        # Pulsanti copia e comprimi
        self.copy_button = ttk.Button(main_buttons_frame, text="Copia selezionati",
                                    command=self.copy_selected,
                                    style="TButton")
        self.copy_button.pack(side=LEFT, padx=5)
        
        self.compress_button = ttk.Button(main_buttons_frame, text="Comprimi selezionati",
                                        command=self.compress_selected,
                                        style="TButton")
        self.compress_button.pack(side=LEFT, padx=5)
        
        # Frame della barra di stato (in basso)
        status_frame = ttk.Frame(self.root)
        status_frame.pack(fill=X, side=BOTTOM, pady=2)
        
        # Frame info (sinistra)
        info_frame = ttk.Frame(status_frame)
        info_frame.pack(side=LEFT, fill=X, expand=YES, padx=5)
        
        # Status label (in basso a sinistra)
        self.status_label = ttk.Label(info_frame, text="In attesa...", justify=LEFT)
        self.status_label.pack(side=LEFT, padx=5)
        
        # DateTime e User label (in basso a destra)
        ttk.Label(status_frame, textvariable=self.datetime_var).pack(side=RIGHT, padx=5)
        
        # Progress bar (sopra la barra di stato)
        progress_frame = ttk.Frame(self.root)
        progress_frame.pack(fill=X, side=BOTTOM, pady=(0, 2))
        
        self.progress_bar = ttk.Progressbar(progress_frame, mode='determinate', length=200)
        self.progress_bar.pack(fill=X, padx=5)
        
        # Aggiungi tooltip ai pulsanti principali
        self.create_tooltip(self.search_button, "Avvia la ricerca con i criteri specificati")
        self.create_tooltip(self.copy_button, "Copia i file selezionati nella directory specificata")
        self.create_tooltip(self.compress_button, "Comprimi i file selezionati in un archivio ZIP")
    
    # Avviso sulla spunta della ricerca dei contenuti
    def warn_content_search(self):
        """Mostra un avviso se l'utente attiva la ricerca nei contenuti"""
        if self.search_content.get():  # Se la checkbox è stata appena attivata
            messagebox.showwarning(
                "Attenzione", 
                "Attivando questa opzione rallenterà la ricerca e l'attesa sarà maggiore.",
                parent=self.root
            )

    def create_tooltip(self, widget, text, delay=500, fade=True):
        """Crea tooltip con ritardo, effetti di dissolvenza e larghezza automatica"""
        
        tooltip_timer = None
        fade_timer = None
        
        def show_tooltip():
            x = widget.winfo_rootx() + 25
            y = widget.winfo_rooty() + 25
            
            tooltip = ttk.Toplevel(widget)
            tooltip.wm_overrideredirect(True)
            tooltip.attributes("-alpha", 0.0)  # Inizia invisibile
            tooltip.attributes("-topmost", True)  # Mantiene sopra altre finestre
            
            # Crea un frame con bordo e padding
            frame = ttk.Frame(tooltip, borderwidth=1, relief="solid", padding=10)
            frame.pack(fill="both", expand=True)
            
            # Calcolo della larghezza del testo
            font = ("Segoe UI", 9)  # Puoi modificare questo per usare un altro font
            
            # Calcola la lunghezza approssimativa del testo
            import tkinter as tk
            temp_label = tk.Label(font=font)
            
            # Determina se il testo necessita di essere diviso in più righe
            lines = text.split("\n")
            max_line_width = 0
            
            for line in lines:
                temp_label.configure(text=line)
                line_width = temp_label.winfo_reqwidth()
                max_line_width = max(max_line_width, line_width)
            
            # Limita la larghezza massima a 500 pixel
            max_width = min(max_line_width, 500)
            
            # Se il testo è più corto della larghezza massima, non imposta wraplength
            # altrimenti imposta wraplength per dividere il testo in righe
            if max_line_width > 500:
                wraplength = 500
            else:
                wraplength = max_line_width
                
            # Crea l'etichetta con il testo
            label = ttk.Label(frame, text=text, justify="left", 
                            wraplength=wraplength, font=font)
            label.pack(fill="both", expand=True)
            
            # Distruggi il label temporaneo
            temp_label.destroy()
            
            # Aggiorna immediatamente per calcolare le dimensioni
            tooltip.update_idletasks()
            
            # Posiziona il tooltip in modo che non vada fuori dallo schermo
            tooltip_width = tooltip.winfo_reqwidth()
            tooltip_height = tooltip.winfo_reqheight()
            
            screen_width = tooltip.winfo_screenwidth()
            screen_height = tooltip.winfo_screenheight()
            
            # Aggiusta la posizione se il tooltip esce dallo schermo
            if x + tooltip_width > screen_width:
                x = screen_width - tooltip_width - 10
            
            if y + tooltip_height > screen_height:
                y = screen_height - tooltip_height - 10
                
            # Imposta la posizione finale
            tooltip.wm_geometry(f"+{x}+{y}")
            
            widget._tooltip = tooltip
            
            if fade:
                # Effetto dissolvenza in entrata
                def fade_in(alpha=0.0):
                    if not hasattr(widget, "_tooltip"):
                        return
                    
                    tooltip.attributes("-alpha", alpha)
                    if alpha < 1.0:
                        nonlocal fade_timer
                        fade_timer = widget.after(20, lambda: fade_in(alpha + 0.1))
                
                fade_in()
        
        def enter(event):
            nonlocal tooltip_timer
            # Avvia il timer per mostrare il tooltip dopo un certo ritardo
            tooltip_timer = widget.after(delay, show_tooltip)
        
        def leave(event):
            nonlocal tooltip_timer, fade_timer
            
            # Cancella il timer se esiste
            if tooltip_timer:
                widget.after_cancel(tooltip_timer)
                tooltip_timer = None
            
            # Cancella il timer di dissolvenza se esiste
            if fade_timer:
                widget.after_cancel(fade_timer)
                fade_timer = None
            
            # Rimuovi il tooltip se esiste
            if hasattr(widget, "_tooltip"):
                if fade:
                    # Effetto dissolvenza in uscita
                    def fade_out(alpha=1.0):
                        if alpha <= 0 or not hasattr(widget, "_tooltip"):
                            if hasattr(widget, "_tooltip"):
                                widget._tooltip.destroy()
                                del widget._tooltip
                        else:
                            widget._tooltip.attributes("-alpha", alpha)
                            nonlocal fade_timer
                            fade_timer = widget.after(20, lambda: fade_out(alpha - 0.1))
                    
                    fade_out()
                else:
                    widget._tooltip.destroy()
                    del widget._tooltip
        
        # Gestisce anche il caso in cui il widget venga distrutto
        def on_destroy(event):
            nonlocal tooltip_timer, fade_timer
            if tooltip_timer:
                widget.after_cancel(tooltip_timer)
            if fade_timer and hasattr(widget, "_tooltip"):
                widget.after_cancel(fade_timer)
                widget._tooltip.destroy()
        
        widget.bind("<Enter>", enter)
        widget.bind("<Leave>", leave)
        widget.bind("<Destroy>", on_destroy)

    def select_all(self):
        self.results_list.selection_set(self.results_list.get_children())
        
    def deselect_all(self):
        self.results_list.selection_remove(self.results_list.get_children())
        
    def invert_selection(self):
        all_items = self.results_list.get_children()
        selected_items = self.results_list.selection()
        self.results_list.selection_remove(selected_items)
        to_select = set(all_items) - set(selected_items)
        for item in to_select:
            self.results_list.selection_add(item)

    def compress_selected(self):
        selected_items = self.results_list.selection()
        if not selected_items:
            messagebox.showwarning("Attenzione", "Seleziona almeno un elemento da comprimere")
            return
            
        zip_name = Querybox.get_string(
            prompt="Inserisci il nome del file ZIP (senza estensione):",
            title="Nome file ZIP",
            initialvalue="archivio"
        )
        
        if not zip_name:
            return
            
        zip_path = filedialog.asksaveasfilename(
            defaultextension=".zip",
            initialfile=f"{zip_name}.zip",
            filetypes=[("ZIP files", "*.zip")],
            title="Salva file ZIP"
        )
        
        if not zip_path:
            return
            
        # Raccogli tutti i file delle cartelle selezionate
        files_in_folders = set()
        folder_paths = []
        single_files = []
        
        # Prima fase: raccogli informazioni su cartelle e file
        for item in selected_items:
            values = self.results_list.item(item)['values']
            item_type, _, _, _, _, source_path = values
            
            if item_type == "Directory":
                folder_paths.append(source_path)
                # Raccogli tutti i file nelle cartelle selezionate
                for root, _, files in os.walk(source_path):
                    for file in files:
                        full_path = os.path.join(root, file)
                        files_in_folders.add(os.path.abspath(full_path))
            else:
                single_files.append(source_path)
        
        # Filtra i file singoli che sono già presenti nelle cartelle
        filtered_single_files = [f for f in single_files if os.path.abspath(f) not in files_in_folders]
        
        total_items = len(folder_paths) + len(filtered_single_files)
        processed = 0
        
        try:
            with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                # Prima comprimi le cartelle
                for folder_path in folder_paths:
                    base_folder = os.path.basename(folder_path)
                    for root, _, files in os.walk(folder_path):
                        for file in files:
                            file_path = os.path.join(root, file)
                            # Mantieni la struttura delle cartelle nel zip
                            rel_path = os.path.relpath(file_path, os.path.dirname(folder_path))
                            zipf.write(file_path, rel_path)
                    
                    processed += 1
                    progress = (processed / total_items) * 100
                    self.progress_bar["value"] = progress
                    self.status_label["text"] = f"Compressi {processed} di {total_items} elementi"
                    self.root.update()
                
                # Poi comprimi i file singoli (solo quelli non già presenti nelle cartelle)
                for file_path in filtered_single_files:
                    if os.path.exists(file_path):  # Verifica che il file esista ancora
                        zipf.write(file_path, os.path.basename(file_path))
                        
                    processed += 1
                    progress = (processed / total_items) * 100
                    self.progress_bar["value"] = progress
                    self.status_label["text"] = f"Compressi {processed} di {total_items} elementi"
                    self.root.update()
            
            # Prepara il messaggio di completamento
            skipped_files = len(single_files) - len(filtered_single_files)
            message = f"Compressione completata!\nFile salvato in: {zip_path}"
            if skipped_files > 0:
                message += f"\n{skipped_files} file saltati perché già presenti nelle cartelle"
                
            messagebox.showinfo("Completato", message)
            
        except Exception as e:
            messagebox.showerror("Errore", f"Errore durante la compressione: {str(e)}")
            
        finally:
            self.progress_bar["value"] = 0
            self.status_label["text"] = "In attesa..."

    def copy_selected(self):
        selected_items = self.results_list.selection()
        if not selected_items:
            messagebox.showwarning("Attenzione", "Seleziona almeno un elemento da copiare")
            return
                
        dest_dir = filedialog.askdirectory(title="Seleziona directory di destinazione")
        if not dest_dir:
            return
            
        # Conteggio elementi
        total = len(selected_items)
        processed = 0
        errors = []
        
        self.progress_bar["value"] = 0
        self.status_label["text"] = "Avvio copia..."
        self.root.update()
        
        try:
            for item in selected_items:
                values = self.results_list.item(item)['values']
                item_type, _, _, _, _, source_path = values
                
                # Assicurati che il percorso esista ancora
                if not os.path.exists(source_path):
                    errors.append(f"Percorso non trovato: {source_path}")
                    continue
                    
                # Nome del file o cartella
                basename = os.path.basename(source_path)
                destination = os.path.join(dest_dir, basename)
                
                # Gestione dei percorsi duplicati
                if os.path.exists(destination):
                    counter = 1
                    name, ext = os.path.splitext(basename)
                    while os.path.exists(os.path.join(dest_dir, f"{name}_{counter}{ext}")):
                        counter += 1
                    destination = os.path.join(dest_dir, f"{name}_{counter}{ext}")
                
                try:
                    if item_type == "Directory":
                        shutil.copytree(source_path, destination)
                    else:
                        shutil.copy2(source_path, destination)
                except Exception as e:
                    errors.append(f"Errore durante la copia di {source_path}: {str(e)}")
                    
                processed += 1
                progress = (processed / total) * 100
                self.progress_bar["value"] = progress
                self.status_label["text"] = f"Copiati {processed} di {total} elementi"
                self.root.update()
                
            if errors:
                error_message = "Completato con errori:\n\n" + "\n".join(errors[:10])
                if len(errors) > 10:
                    error_message += f"\n\n... e altri {len(errors) - 10} errori."
                messagebox.showwarning("Attenzione", error_message)
            else:
                messagebox.showinfo("Completato", f"Copia completata con successo!\n{processed} elementi copiati in:\n{dest_dir}")
                
        except Exception as e:
            messagebox.showerror("Errore", f"Errore durante il processo di copia: {str(e)}")
            
        finally:
            self.progress_bar["value"] = 0
            self.status_label["text"] = "In attesa..."

    def _search_thread(self, search_path, search_terms, search_content=False):
        """Thread principale di ricerca"""
        try:
            # Inizializza l'executor per la ricerca parallela nei contenuti
            max_workers = self.worker_threads.get()
            self.search_executor = concurrent.futures.ThreadPoolExecutor(max_workers=max_workers)
            futures = []
            
            # Contatori per statistiche
            files_checked = 0
            dirs_checked = 0
            start_time = time.time()
            timeout = self.timeout_seconds.get() if self.timeout_enabled.get() else 0
            
            # Segnala avvio ricerca
            self.progress_queue.put(("status", "Ricerca avviata..."))
            
            # Filtri avanzati
            min_size = self.advanced_filters["size_min"]
            max_size = self.advanced_filters["size_max"]
            min_date_str = self.advanced_filters["date_min"]
            max_date_str = self.advanced_filters["date_max"]
            extensions = self.advanced_filters["extensions"]
            
            # Converti stringhe di date in oggetti datetime
            min_date = None
            max_date = None
            
            if min_date_str:
                try:
                    min_date = datetime.strptime(min_date_str, "%d-%m-%Y")
                except ValueError:
                    self.log_debug(f"Data minima non valida: {min_date_str}")
            
            if max_date_str:
                try:
                    max_date = datetime.strptime(max_date_str, "%d-%m-%Y")
                    # Imposta l'ora alla fine della giornata
                    max_date = datetime.combine(max_date.date(), datetime.max.time())
                except ValueError:
                    self.log_debug(f"Data massima non valida: {max_date_str}")
            
            # Funzioni helper per la ricerca
            def check_file_match(file_path, file_name, size, modified_time):
                """Verifica se un file corrisponde ai criteri di ricerca base senza analizzare il contenuto"""
                # Verifica estensione
                if extensions and not any(file_name.lower().endswith(ext.lower()) for ext in extensions):
                    return False
                
                # Verifica dimensione
                if min_size > 0 and size < min_size:
                    return False
                if max_size > 0 and size > max_size:
                    return False
                
                # Verifica data
                if min_date and modified_time < min_date:
                    return False
                if max_date and modified_time > max_date:
                    return False
                
                # Verifica parole chiave nel nome
                if not any(term.lower() in file_name.lower() for term in search_terms):
                    # Se le parole chiave non sono nel nome, verifica se dobbiamo cercare nei contenuti
                    if not search_content:
                        return False
                    # Se dobbiamo cercare nei contenuti, restituisci True per continuare la verifica
                    return True
                
                # Se arriviamo qui, il file corrisponde ai criteri di base
                return True
            
            def search_in_file_content(file_path, file_ext):
                """Cerca nei contenuti del file basandosi sull'estensione"""
                try:
                    # Controlla la dimensione del file
                    file_size = os.path.getsize(file_path)
                    max_size_bytes = self.max_file_size_mb.get() * 1024 * 1024
                    
                    if file_size > max_size_bytes:
                        return False
                    
                    # Cerca nei vari tipi di file supportati
                    ext_lower = file_ext.lower()
                    
                    # File di testo semplice
                    if ext_lower in ['.txt', '.log', '.md', '.csv', '.json', '.xml', '.html', '.htm']:
                        try:
                            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                                content = f.read()
                                return any(term.lower() in content.lower() for term in search_terms)
                        except Exception as e:
                            self.log_debug(f"Errore lettura file {file_path}: {str(e)}")
                            return False
                    
                    # File Word (.docx)
                    elif ext_lower == '.docx' and file_format_support["docx"]:
                        try:
                            doc = docx.Document(file_path)
                            text = " ".join([paragraph.text for paragraph in doc.paragraphs])
                            return any(term.lower() in text.lower() for term in search_terms)
                        except Exception as e:
                            self.log_debug(f"Errore lettura DOCX {file_path}: {str(e)}")
                            return False
                    
                    # File PDF
                    elif ext_lower == '.pdf' and file_format_support["pdf"]:
                        try:
                            with open(file_path, 'rb') as f:
                                reader = PyPDF2.PdfFileReader(f)
                                text = ""
                                for page_num in range(reader.numPages):
                                    try:
                                        text += reader.getPage(page_num).extractText()
                                    except:
                                        pass
                                return any(term.lower() in text.lower() for term in search_terms)
                        except Exception as e:
                            self.log_debug(f"Errore lettura PDF {file_path}: {str(e)}")
                            return False
                    
                    # File PowerPoint
                    elif ext_lower == '.pptx' and file_format_support["pptx"]:
                        try:
                            presentation = pptx.Presentation(file_path)
                            text = ""
                            for slide in presentation.slides:
                                for shape in slide.shapes:
                                    if hasattr(shape, "text"):
                                        text += shape.text
                            return any(term.lower() in text.lower() for term in search_terms)
                        except Exception as e:
                            self.log_debug(f"Errore lettura PPTX {file_path}: {str(e)}")
                            return False
                    
                    # File Excel
                    elif ext_lower in ['.xlsx', '.xls'] and file_format_support["excel"]:
                        try:
                            workbook = openpyxl.load_workbook(file_path, read_only=True, data_only=True)
                            text = ""
                            for sheet_name in workbook.sheetnames:
                                sheet = workbook[sheet_name]
                                for row in sheet.iter_rows(values_only=True):
                                    for cell in row:
                                        if cell is not None:
                                            text += str(cell) + " "
                            return any(term.lower() in text.lower() for term in search_terms)
                        except Exception as e:
                            self.log_debug(f"Errore lettura Excel {file_path}: {str(e)}")
                            return False
                    
                    # File RTF
                    elif ext_lower == '.rtf' and file_format_support["rtf"]:
                        try:
                            with open(file_path, 'r', errors='ignore') as f:
                                rtf_content = f.read()
                                text = rtf_to_text(rtf_content)
                                return any(term.lower() in text.lower() for term in search_terms)
                        except Exception as e:
                            self.log_debug(f"Errore lettura RTF {file_path}: {str(e)}")
                            return False
                    
                    # File OpenDocument (.odt)
                    elif ext_lower == '.odt' and file_format_support["odt"]:
                        try:
                            doc = odfdo.Document(file_path)
                            text = doc.get_formatted_text()
                            return any(term.lower() in text.lower() for term in search_terms)
                        except NameError:
                            # Prova con l'altra libreria ODT
                            try:
                                odt_doc = opendocument.load(file_path)
                                text = ""
                                for element in odt_doc.getElementsByType(text.P):
                                    text += teletype.extractText(element) + " "
                                return any(term.lower() in text.lower() for term in search_terms)
                            except Exception as e:
                                self.log_debug(f"Errore lettura ODT {file_path}: {str(e)}")
                                return False
                        except Exception as e:
                            self.log_debug(f"Errore lettura ODT {file_path}: {str(e)}")
                            return False
                    
                    # Per altri tipi di file, non cerchiamo nel contenuto
                    return False
                    
                except Exception as e:
                    self.log_debug(f"Errore analisi contenuto {file_path}: {str(e)}")
                    return False
            
            # Inizia la ricerca ricorsiva
            for root, dirs, files in os.walk(search_path):
                # Controlla se la ricerca è stata interrotta
                if self.stop_search:
                    self.progress_queue.put(("status", "Ricerca interrotta dall'utente"))
                    self.progress_queue.put(("complete", True))
                    if self.search_executor:
                        self.search_executor.shutdown(wait=False)
                    return
                    
                # Verifica se è scaduto il timeout
                if timeout > 0 and time.time() - start_time > timeout:
                    self.progress_queue.put(("status", "Timeout ricerca"))
                    self.progress_queue.put(("timeout", True))
                    if self.search_executor:
                        self.search_executor.shutdown(wait=False)
                    return
                    
                # Controlla la profondità 
                current_depth = root[len(search_path):].count(os.path.sep)
                if self.max_depth > 0 and current_depth >= self.max_depth:
                    dirs[:] = []  # Non scendere ulteriormente nelle directory
                
                # Salta cartelle nascoste se richiesto
                if self.ignore_hidden.get():
                    dirs[:] = [d for d in dirs if not d.startswith('.')]
                    files = [f for f in files if not f.startswith('.')]
                    
                # Cerca nelle directory se richiesto
                if self.search_folders.get():
                    for dir_name in dirs:
                        dirs_checked += 1
                        
                        # Segnala progresso
                        if dirs_checked % 10 == 0:
                            self.progress_queue.put(("status", f"Analizzando: {dirs_checked} cartelle, {files_checked} file"))
                        
                        # Verifica se il nome della directory corrisponde
                        if any(term.lower() in dir_name.lower() for term in search_terms):
                            dir_path = os.path.join(root, dir_name)
                            modified_time = datetime.fromtimestamp(os.path.getmtime(dir_path))
                            created_time = datetime.fromtimestamp(os.path.getctime(dir_path))
                            
                            # Verifica filtri data
                            if min_date and modified_time < min_date:
                                continue
                            if max_date and modified_time > max_date:
                                continue
                                
                            # Aggiunge risultato
                            self.search_results.append({
                                'type': "Directory",
                                'name': dir_name,
                                'size': "-",
                                'modified': modified_time.strftime('%d-%m-%Y %H:%M'),
                                'created': created_time.strftime('%d-%m-%Y %H:%M'),
                                'path': dir_path
                            })
                
                # Cerca nei file se richiesto
                if self.search_files.get():
                    for file_name in files:
                        files_checked += 1
                        
                        # Verifica limitazione numero file
                        if files_checked >= self.max_files_to_check.get():
                            self.progress_queue.put(("status", f"Raggiunto limite di {self.max_files_to_check.get()} file"))
                            break
                            
                        # Aggiorna progresso periodicamente
                        if files_checked % 50 == 0:
                            self.progress_queue.put(("status", f"Analizzati {files_checked} file in {dirs_checked} cartelle"))
                            self.progress_queue.put(("progress", min(90, int(files_checked / self.max_files_to_check.get() * 100))))
                        
                        # Processa il file
                        file_path = os.path.join(root, file_name)
                        try:
                            # Ottieni metadati del file
                            file_size = os.path.getsize(file_path)
                            modified_time = datetime.fromtimestamp(os.path.getmtime(file_path))
                            created_time = datetime.fromtimestamp(os.path.getctime(file_path))
                            
                            # Estensione file
                            _, file_ext = os.path.splitext(file_name)
                            
                            # Tipo di file (basato su MIME type)
                            mime_type, _ = mimetypes.guess_type(file_path)
                            file_type = mime_type if mime_type else f"File {file_ext}"
                            
                            # Verifica preliminare (senza analizzare il contenuto)
                            if check_file_match(file_path, file_name, file_size, modified_time):
                                # Se dobbiamo cercare nel contenuto
                                content_match = True  # Default a True se non è necessario cercare nel contenuto
                                
                                if search_content and not any(term.lower() in file_name.lower() for term in search_terms):
                                    # Aggiungi il task alla coda
                                    future = self.search_executor.submit(search_in_file_content, file_path, file_ext)
                                    futures.append((future, {
                                        'type': file_type,
                                        'name': file_name,
                                        'size': self.format_size(file_size),
                                        'modified': modified_time.strftime('%d-%m-%Y %H:%M'),
                                        'created': created_time.strftime('%d-%m-%Y %H:%M'),
                                        'path': file_path
                                    }))
                                    content_match = False  # Da determinare in base al risultato future
                                
                                # Se corrisponde al nome o non dobbiamo cercare nel contenuto
                                if any(term.lower() in file_name.lower() for term in search_terms):
                                    self.search_results.append({
                                        'type': file_type,
                                        'name': file_name,
                                        'size': self.format_size(file_size),
                                        'modified': modified_time.strftime('%d-%m-%Y %H:%M'),
                                        'created': created_time.strftime('%d-%m-%Y %H:%M'),
                                        'path': file_path
                                    })
                                    
                                    # Verifica limitazione risultati
                                    if len(self.search_results) >= self.max_results.get():
                                        self.progress_queue.put(("status", f"Raggiunto limite di {self.max_results.get()} risultati"))
                                        break
                        
                        except Exception as e:
                            self.log_debug(f"Errore processando {file_path}: {str(e)}")
                    
                    # Verifica se è necessario arrestare la ricerca
                    if len(self.search_results) >= self.max_results.get():
                        break
            
            # Attendi il completamento delle ricerche nei contenuti
            completed_futures = 0
            for future, result_data in futures:
                try:
                    if future.done() or future.running():
                        content_found = future.result(timeout=2)  # Piccolo timeout per evitare blocchi
                        if content_found:
                            self.search_results.append(result_data)
                            # Verifica limitazione risultati
                            if len(self.search_results) >= self.max_results.get():
                                break
                except concurrent.futures.TimeoutError:
                    pass  # Ignora i task che impiegano troppo tempo
                except Exception as e:
                    self.log_debug(f"Errore nel future: {str(e)}")
                    
                completed_futures += 1
                if completed_futures % 10 == 0:
                    progress = min(95, 90 + int(completed_futures / max(1, len(futures)) * 5))
                    self.progress_queue.put(("progress", progress))
                    self.progress_queue.put(("status", f"Completata analisi di {completed_futures}/{len(futures)} contenuti"))
                    
                # Verifica interruzioni
                if self.stop_search:
                    break
                    
            # Chiudi l'executor
            if self.search_executor:
                self.search_executor.shutdown(wait=False)
                self.search_executor = None
                
            # Segnalazione completamento
            self.progress_queue.put(("status", f"Ricerca completata! Trovati {len(self.search_results)} risultati"))
            self.progress_queue.put(("progress", 100))
            self.progress_queue.put(("complete", True))
            
        except Exception as e:
            self.log_debug(f"Errore nel thread di ricerca: {traceback.format_exc()}")
            self.progress_queue.put(("error", f"Errore durante la ricerca: {str(e)}"))
            if self.search_executor:
                self.search_executor.shutdown(wait=False)
                self.search_executor = None

    def search_file_content(self, file_path, search_terms):
        """Cerca i termini nel contenuto del file e restituisce il risultato se trovato"""
        try:
            # Verifica se il file è già stato indicizzato
            if self.use_indexing.get() and file_path in self.search_index:
                # Controlla se uno dei termini è nel contenuto indicizzato
                if any(term.lower() in self.search_index[file_path].lower() for term in search_terms):
                    file_type = self.get_file_type(file_path)
                    metadata = self.get_file_metadata(file_path)
                    return {
                        'type': file_type,
                        'author': os.path.basename(file_path),
                        'size': metadata['size'],
                        'modified': metadata['modified'],
                        'created': metadata['created'],
                        'path': file_path
                    }
                return None
            
            # Estrazione testo basata sul tipo di file
            content = self.extract_text_from_file(file_path)
            content_lower = content.lower()
            
            # Salva il contenuto nell'indice se indicizzazione è attiva
            if self.use_indexing.get():
                self.search_index[file_path] = content
            
            # Ricerca dei termini nel contenuto
            if any(term.lower() in content_lower for term in search_terms):
                file_type = self.get_file_type(file_path)
                metadata = self.get_file_metadata(file_path)
                return {
                    'type': file_type,
                    'author': os.path.basename(file_path),
                    'size': metadata['size'],
                    'modified': metadata['modified'],
                    'created': metadata['created'],
                    'path': file_path
                }
            
            return None
        except Exception as e:
            self.log_debug(f"Errore nell'analisi del contenuto di {file_path}: {str(e)}")
            return None

    def safe_listdir(self, directory):
        """Versione sicura di os.listdir che gestisce errori di permesso"""
        try:
            return os.listdir(directory)
        except PermissionError:
            self.log_debug(f"Permesso negato per la directory {directory}")
            return None
        except Exception as e:
            self.log_debug(f"Errore nell'accesso alla directory {directory}: {str(e)}")
            return None

    def get_file_type(self, file_path, mime_cache=None):
        """Determina il tipo di file con cache per migliorare le prestazioni"""
        try:
            if os.path.isdir(file_path):
                return "Directory"
            
            # Se è stata fornita una cache, usa quella
            if mime_cache is not None and file_path in mime_cache:
                return mime_cache[file_path]
            
            # Ottieni l'estensione in minuscolo
            ext = os.path.splitext(file_path)[1].lower()
            
            # Mappa delle estensioni
            file_types = {
                # Documenti
                '.doc': 'Word Document',
                '.docx': 'Word Document',
                '.pdf': 'PDF Document',
                '.txt': 'Text Document',
                '.rtf': 'Rich Text Format',
                '.odt': 'OpenDocument Text',
                
                # Fogli di calcolo
                '.xls': 'Excel Workbook',
                '.xlsx': 'Excel Workbook',
                '.ods': 'OpenDocument Spreadsheet',
                
                # Presentazioni
                '.ppt': 'PowerPoint Presentation',
                '.pptx': 'PowerPoint Presentation',
                '.odp': 'OpenDocument Presentation',
                
                # Immagini
                '.jpg': 'JPEG Image',
                '.jpeg': 'JPEG Image',
                '.png': 'PNG Image',
                '.gif': 'GIF Image',
                '.bmp': 'Bitmap Image',
                '.tiff': 'TIFF Image',
                '.webp': 'WebP Image',
                
                # Media
                '.mp3': 'MP3 Audio',
                '.mp4': 'MP4 Video',
                '.wav': 'WAV Audio',
                '.avi': 'AVI Video',
                '.mov': 'MOV Video',
                '.flac': 'FLAC Audio',
                
                # Archivi
                '.zip': 'ZIP Archive',
                '.rar': 'RAR Archive',
                '.7z': '7-Zip Archive',
                '.tar': 'TAR Archive',
                '.gz': 'GZip Archive',
                
                # Programmi
                '.exe': 'Executable File',
                '.dll': 'Dynamic Link Library',
                '.app': 'macOS Application',
                '.bat': 'Batch File',
                '.sh': 'Shell Script',
                
                # Altri formati
                '.html': 'HTML Document',
                '.css': 'CSS File',
                '.js': 'JavaScript File',
                '.json': 'JSON File',
                '.xml': 'XML File',
                '.py': 'Python Script',
                '.java': 'Java Source File',
                '.c': 'C Source File',
                '.cpp': 'C++ Source File',
            }
            
            # Restituisce il tipo di file o un tipo generico se non trovato
            file_type = file_types.get(ext, f'File{ext}' if ext else 'Unknown File')
            
            # Memorizza il risultato nella cache se disponibile
            if mime_cache is not None:
                mime_cache[file_path] = file_type
                
            return file_type
        
        except Exception as e:
            self.log_debug(f"Errore nel determinare il tipo di file per {file_path}: {str(e)}")
            return "Unknown File"

    def get_file_metadata(self, file_path):
        """Estrae i metadati dal file specificato con cache per migliorare le prestazioni"""
        try:
            # Ottiene le statistiche del file
            file_stat = os.stat(file_path)
            
            # Calcola la dimensione del file in formato leggibile
            size_bytes = file_stat.st_size
            if size_bytes < 1024:
                size_str = f"{size_bytes} B"
            elif size_bytes < 1024 * 1024:
                size_str = f"{size_bytes / 1024:.1f} KB"
            elif size_bytes < 1024 * 1024 * 1024:
                size_str = f"{size_bytes / (1024 * 1024):.1f} MB"
            else:
                size_str = f"{size_bytes / (1024 * 1024 * 1024):.2f} GB"
            
            # Ottiene le date di modifica e creazione nel formato YYYY-MM-DD HH:MM:SS
            mod_time = datetime.fromtimestamp(file_stat.st_mtime).strftime('%Y-%m-%d %H:%M:%S')
            
            # In Windows st_ctime è la data di creazione, in Unix è la data di cambio stato
            if os.name == 'nt':  # Windows
                create_time = datetime.fromtimestamp(file_stat.st_ctime).strftime('%Y-%m-%d %H:%M:%S')
            else:  # Unix/Linux/Mac
                create_time = datetime.fromtimestamp(file_stat.st_atime).strftime('%Y-%m-%d %H:%M:%S')
            
            return {
                "size": size_str,
                "modified": mod_time,
                "created": create_time
            }
        except Exception as e:
            self.log_debug(f"Errore nell'estrazione dei metadati per {file_path}: {e}")
            return {
                "size": "N/A",
                "modified": "N/A", 
                "created": "N/A"
            }

    def is_text_file(self, file_path):
        """Verifica se un file è probabilmente un file di testo leggibile o un documento supportato"""
        # Ignora i file temporanei di Office
        if os.path.basename(file_path).startswith("~$"):
            return False
            
        # Verifica l'estensione del file
        ext = os.path.splitext(file_path)[1].lower()
        
        # File di Office comuni
        office_extensions = [
            '.docx', '.doc',   # Word
            '.xlsx', '.xls',   # Excel
            '.pptx', '.ppt',   # PowerPoint
            '.odt', '.ods', '.odp',  # OpenDocument
            '.rtf',            # Rich Text Format
            '.pdf'             # PDF
        ]
        
        # Se è un file Office supportato, verifica che sia disponibile la libreria corrispondente
        if ext in ['.docx', '.doc'] and not file_format_support["docx"]:
            return False
        if ext == '.pdf' and not file_format_support["pdf"]:
            return False
        if ext in ['.pptx', '.ppt'] and not file_format_support["pptx"]:
            return False
        if ext in ['.xlsx', '.xls'] and not file_format_support["excel"]:
            return False
        if ext in ['.odt', '.ods', '.odp'] and not file_format_support["odt"]:
            return False
        if ext == '.rtf' and not file_format_support["rtf"]:
            return False
        
        # Verifica se è un file office supportato
        if ext in office_extensions:
            # Controlla la dimensione del file
            try:
                file_size = os.path.getsize(file_path)
                max_size = self.max_file_size_mb.get() * 1024 * 1024
                if file_size > max_size:
                    self.log_debug(f"File troppo grande: {file_path} ({file_size/1024/1024:.1f}MB > {self.max_file_size_mb.get()}MB)")
                    return False
                return True
            except:
                return False
            
        # Estensioni comuni di file di testo
        text_extensions = ['.txt', '.py', '.java', '.c', '.cpp', '.h', '.html', '.css', '.js', '.json', '.xml', '.md', 
                        '.log', '.csv', '.ini', '.cfg', '.config', '.bat', '.sh', '.ps1', '.tex', '.sql']
        
        if ext in text_extensions:
            # Controlla la dimensione del file
            try:
                file_size = os.path.getsize(file_path)
                max_size = self.max_file_size_mb.get() * 1024 * 1024
                if file_size > max_size:
                    return False
                return True
            except:
                return False
        
        # Per file senza estensione, prova a leggere i primi byte
        if not ext:
            try:
                with open(file_path, 'rb') as f:
                    sample = f.read(1024)
                    # Verifica che sia un file di testo (ASCII o UTF-8)
                    return all(c < 127 for c in sample if c != 0)
            except:
                return False
        
        return False

    def extract_text_from_file(self, file_path):
        """Estrae il testo da vari tipi di file con ottimizzazioni"""
        # Ignora i file temporanei di Office
        if os.path.basename(file_path).startswith("~$"):
            return ""
                
        ext = os.path.splitext(file_path)[1].lower()
        
        try:
            # File Word (.docx, .doc)
            if ext == '.docx' and file_format_support["docx"]:
                try:
                    doc = docx.Document(file_path)
                    return '\n'.join([paragraph.text for paragraph in doc.paragraphs])
                except Exception as e:
                    self.log_debug(f"Errore nell'estrazione del testo da file Word {file_path}: {e}")
                    return ""
            
            # File OpenDocument (.odt, .ods, .odp)
            elif ext in ['.odt', '.ods', '.odp'] and file_format_support["odt"]:
                try:
                    if 'odfdo' in globals():
                        doc = odfdo.Document(file_path)
                        body = doc.body
                        all_text = body.get_formatted_text()
                        return all_text
                    
                    elif 'opendocument' in dir():
                        doc = opendocument.load(file_path)
                        all_paragraphs = []
                        for paragraph in doc.getElementsByType(text.P):
                            all_paragraphs.append(teletype.extractText(paragraph))
                        result = '\n'.join(all_paragraphs)
                        return result
                    
                    # Metodo alternativo usando zipfile
                    else:
                        return self._extract_from_zip(file_path, 'content.xml')
                except Exception as e:
                    self.log_debug(f"Errore nell'estrazione del testo da file OpenDocument {file_path}: {e}")
                    return self._extract_from_zip(file_path, 'content.xml')
            
            # File Excel (.xlsx, .xls)
            elif ext in ['.xlsx', '.xls'] and file_format_support["excel"]:
                try:
                    workbook = openpyxl.load_workbook(file_path, read_only=True, data_only=True)
                    text_content = []
                    for sheet_name in workbook.sheetnames:
                        sheet = workbook[sheet_name]
                        # Limita il numero di righe e colonne per migliorare le prestazioni
                        max_row = min(sheet.max_row, 1000)
                        max_col = min(sheet.max_column, 50)
                        for row in range(1, max_row + 1):
                            row_text = []
                            for col in range(1, max_col + 1):
                                cell = sheet.cell(row=row, column=col)
                                if cell.value is not None:
                                    row_text.append(str(cell.value))
                            if row_text:
                                text_content.append(' '.join(row_text))
                    return '\n'.join(text_content)
                except Exception as e:
                    self.log_debug(f"Errore nell'estrazione del testo da file Excel {file_path}: {e}")
                    return ""
            
            # File PowerPoint (.pptx, .ppt)
            elif ext in ['.pptx', '.ppt'] and file_format_support["pptx"]:
                try:
                    presentation = pptx.Presentation(file_path)
                    text_content = []
                    for slide in presentation.slides:
                        slide_texts = []
                        for shape in slide.shapes:
                            if hasattr(shape, "text"):
                                slide_texts.append(shape.text)
                        if slide_texts:
                            text_content.append('\n'.join(slide_texts))
                    return '\n'.join(text_content)
                except Exception as e:
                    self.log_debug(f"Errore nell'estrazione del testo da file PowerPoint {file_path}: {e}")
                    return ""
            
            # File PDF - con limite pagine per prestazioni
            elif ext == '.pdf' and file_format_support["pdf"]:
                try:
                    with open(file_path, 'rb') as f:
                        reader = PyPDF2.PdfReader(f)
                        text_content = []
                        # Limita il numero di pagine da analizzare per prestazioni
                        max_pages = min(len(reader.pages), 50)
                        for page_num in range(max_pages):
                            text_content.append(reader.pages[page_num].extract_text())
                    return '\n'.join(text_content)
                except Exception as e:
                    self.log_debug(f"Errore nell'estrazione del testo da file PDF {file_path}: {e}")
                    return ""
            
            # File RTF
            elif ext == '.rtf' and file_format_support["rtf"]:
                try:
                    with open(file_path, 'r', errors='ignore') as f:
                        rtf_content = f.read()
                    return rtf_to_text(rtf_content)
                except Exception as e:
                    self.log_debug(f"Errore nell'estrazione del testo da file RTF {file_path}: {e}")
                    return ""
            
            # File di testo normali - lettura ottimizzata a blocchi
            else:
                return self._read_text_file_optimized(file_path)
                
        except Exception as e:
            self.log_debug(f"Errore generale nell'estrazione del testo da {file_path}: {e}")
            return ""
    
    def _read_text_file_optimized(self, file_path):
        """Legge un file di testo in modo ottimizzato usando chunking"""
        try:
            max_size = self.max_file_size_mb.get() * 1024 * 1024
            chunk_size = self.chunk_size
            
            # Controlla la dimensione del file
            file_size = os.path.getsize(file_path)
            if file_size > max_size:
                self.log_debug(f"File troppo grande per lettura completa: {file_path}")
                # Legge solo i primi e ultimi N blocchi
                text_chunks = []
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    # Leggi i primi 5 blocchi
                    for _ in range(5):
                        chunk = f.read(chunk_size)
                        if not chunk:
                            break
                        text_chunks.append(chunk)
                    
                    # Salta al 90% del file
                    if file_size > 10 * chunk_size:
                        f.seek(int(file_size * 0.9))
                        
                        # Leggi gli ultimi 5 blocchi
                        for _ in range(5):
                            chunk = f.read(chunk_size)
                            if not chunk:
                                break
                            text_chunks.append(chunk)
                
                return ''.join(text_chunks)
            else:
                # Leggi il file intero
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    return f.read()
        except Exception as e:
            self.log_debug(f"Errore nella lettura ottimizzata di {file_path}: {e}")
            return ""

    def _extract_from_zip(self, file_path, internal_file):
        """Estrae un file da un archivio zip (usato per OpenDocument)"""
        try:
            import zipfile
            import re
            
            with zipfile.ZipFile(file_path) as z:
                if internal_file in z.namelist():
                    with z.open(internal_file) as f:
                        content = f.read().decode('utf-8')
                        # Rimuovi i tag XML per ottenere solo il testo
                        text_only = re.sub(r'<[^>]+>', ' ', content)
                        return text_only
                return ""
        except Exception as e:
            self.log_debug(f"Errore nell'estrazione da ZIP {file_path}: {e}")
            return ""

    def apply_advanced_filters(self, file_path):
        """Controlla se un file corrisponde ai filtri avanzati"""
        try:
            # Filtro dimensione
            if self.advanced_filters["size_min"] > 0 or self.advanced_filters["size_max"] > 0:
                try:
                    file_size = os.path.getsize(file_path)
                    if self.advanced_filters["size_min"] > 0 and file_size < self.advanced_filters["size_min"]:
                        return False
                    if self.advanced_filters["size_max"] > 0 and file_size > self.advanced_filters["size_max"]:
                        return False
                except:
                    pass
            
            # Filtro data
            if self.advanced_filters["date_min"] or self.advanced_filters["date_max"]:
                try:
                    file_time = os.path.getmtime(file_path)
                    file_date = datetime.fromtimestamp(file_time)
                    
                    # Controlla data minima
                    if self.advanced_filters["date_min"] and self.advanced_filters["date_min"].strip():
                        min_date = datetime.strptime(self.advanced_filters["date_min"], "%d-%m-%Y")
                        min_date = min_date.replace(hour=0, minute=0, second=0, microsecond=0)
                        if file_date < min_date:
                            return False
                    
                    # Controlla data massima
                    if self.advanced_filters["date_max"] and self.advanced_filters["date_max"].strip():
                        max_date = datetime.strptime(self.advanced_filters["date_max"], "%d-%m-%Y")
                        max_date = max_date.replace(hour=23, minute=59, second=59, microsecond=999999)
                        if file_date > max_date:
                            return False
                except:
                    pass
            
            # Filtro estensione
            if self.advanced_filters["extensions"]:
                _, ext = os.path.splitext(file_path)
                if ext.lower() not in [e.lower() for e in self.advanced_filters["extensions"]]:
                    return False
            
            # Se arriva qui, il file è passato attraverso tutti i filtri
            return True
        except Exception as e:
            self.log_debug(f"Errore nei filtri avanzati per {os.path.basename(file_path)}: {str(e)}")
            return True  # In caso di errore generale, include il file (più conservativo)

    def format_size(self, size_bytes):
        """Formatta la dimensione del file in unità leggibili"""
        if size_bytes == 0 or size_bytes == "-":
            return "-"
        
        size_names = ["B", "KB", "MB", "GB", "TB"]
        size = float(size_bytes)
        i = 0
        while size >= 1024 and i < len(size_names) - 1:
            size /= 1024
            i += 1
        
        return f"{size:.1f} {size_names[i]}"

    def update_results_list(self):
        """Aggiorna la lista dei risultati nella UI rispettando il tema"""
        # Cancella gli elementi precedenti
        for item in self.results_list.get_children():
            self.results_list.delete(item)
        
        # Aggiunge i nuovi risultati
        if not self.search_results:
            return
        
        # Ottieni lo stile e il tema corrente
        style = ttk.Style()
        
        # Forza l'applicazione del colore di sfondo della treeview
        treeview_bg = style.lookup('Treeview', 'background')
        treeview_fg = style.lookup('Treeview', 'foreground')
        select_bg = style.lookup('Treeview', 'selectbackground')
        
        # Usa colori leggermente diversi per l'alternanza delle righe
        if self._is_dark_theme():
            # Per temi scuri
            odd_color = self._adjust_color(treeview_bg, 15)  # Leggermente più chiaro
            even_color = treeview_bg  # Colore base
        else:
            # Per temi chiari
            odd_color = self._adjust_color(treeview_bg, -10)  # Leggermente più scuro
            even_color = treeview_bg  # Colore base
        
        # Configura i tag per i colori alternati
        self.results_list.tag_configure("odd", background=odd_color)
        self.results_list.tag_configure("even", background=even_color)
        
        # Imposta il colore di sfondo principale della Treeview
        style.configure("Treeview", background=treeview_bg, foreground=treeview_fg)
        
        # Risolve un problema con il colore di sfondo nelle celle
        style.map('Treeview', 
                background=[('selected', select_bg)],
                foreground=[('selected', 'white')])
        
        # Aggiungi risultati con i tag appropriati
        for idx, result in enumerate(self.search_results):
            # Limita i risultati visualizzati
            if idx >= self.max_results.get():
                break
                
            # Colore alternato per le righe
            tags = ("even",) if idx % 2 == 0 else ("odd",)
            
            # Aggiunge l'elemento
            self.results_list.insert("", "end", values=(
                result['type'],
                result['name'],
                result['size'],
                result['modified'],
                result['created'],
                result['path']
            ), tags=tags)

    def _is_dark_theme(self):
        """Determina se il tema corrente è scuro"""
        style = ttk.Style()
        bg_color = style.lookup('TFrame', 'background')
        
        # Se non riesce a ottenere il colore
        if not bg_color:
            # Usa una lista di temi noti
            dark_themes = ["darkly", "solar", "superhero", "cyborg", "vapor", "morph"]
            return style.theme_use() in dark_themes
        
        # Verifica il colore di sfondo (se il formato è #RRGGBB)
        if bg_color.startswith('#') and len(bg_color) == 7:
            # Converti in RGB
            r = int(bg_color[1:3], 16)
            g = int(bg_color[3:5], 16)
            b = int(bg_color[5:7], 16)
            
            # Calcola la luminosità (formula approssimativa)
            brightness = (r * 299 + g * 587 + b * 114) / 1000
            
            # Se la luminosità è inferiore a 128, è un tema scuro
            return brightness < 128
        
        # Fallback per i temi conosciuti
        return style.theme_use() in ["darkly", "solar", "superhero", "cyborg", "vapor", "morph"]

    def _adjust_color(self, hex_color, amount):
        """Schiarisce o scurisce un colore esadecimale"""
        # Se il colore non è nel formato esadecimale standard
        if not hex_color or not hex_color.startswith('#') or len(hex_color) != 7:
            return hex_color  # Ritorna il colore originale
        
        # Converti in RGB
        r = int(hex_color[1:3], 16)
        g = int(hex_color[3:5], 16)
        b = int(hex_color[5:7], 16)
        
        # Aggiusta i valori RGB
        r = max(0, min(255, r + amount))
        g = max(0, min(255, g + amount))
        b = max(0, min(255, b + amount))
        
        # Ritorna il nuovo colore in formato hex
        return f'#{r:02x}{g:02x}{b:02x}'

    def update_theme_colors(self):
        """Aggiorna i colori dell'interfaccia quando viene cambiato il tema"""
        style = ttk.Style()
        current_theme = style.theme_use()
        
        # Imposta i colori alternati in base al tema
        if current_theme in ["darkly", "solar", "superhero", "cyborg", "vapor", "morph"]:
            odd_color = "#2a2a2a"
            even_color = "#363636"
        else:
            odd_color = "#f0f0f0"
            even_color = "#ffffff"
        
        # Aggiorna i tag
        self.results_list.tag_configure("odd", background=odd_color)
        self.results_list.tag_configure("even", background=even_color)

def main():
    root = ttk.Window(themename="darkly")
    app = FileSearchApp(root)
    
    # Imposta l'icona dell'applicazione se disponibile
    try:
        icon_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "icon.ico")
        if os.path.exists(icon_path):
            root.iconbitmap(icon_path)
    except:
        pass
    
    # Centra la finestra sullo schermo
    root.update_idletasks()
    width = root.winfo_width()
    height = root.winfo_height()
    x = (root.winfo_screenwidth() // 2) - (width // 2)
    y = (root.winfo_screenheight() // 2) - (height // 2)
    root.geometry('{}x{}+{}+{}'.format(width, height, x, y))
    
    # Imposta data e ora attuali, username
    current_datetime = "2025-03-13 09:43:46"
    username = "Antonino"
    
    # Aggiorna la barra di stato con data/ora e username
    app.datetime_var.set(f"Data: {current_datetime} | Utente: {username}")
    
    root.mainloop()

if __name__ == "__main__":
    main()
