import os
import sys  # Aggiungo l'import di sys
import shutil
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from tkinter import filedialog, messagebox, BooleanVar, StringVar, IntVar
import threading
import queue
from datetime import datetime
import getpass
import zipfile
from ttkbootstrap.dialogs import Querybox
import traceback
import time
import concurrent.futures
import mimetypes
import signal

# Dizionario per tracciare il supporto alle librerie
file_format_support = {
    "docx": False,
    "pdf": False,
    "pptx": False,
    "excel": False,
    "odt": False,
    "rtf": False
}

# Elenco di librerie da installare se mancanti
missing_libraries = []

# Importazione di librerie opzionali con gestione degli errori
try:
    import docx
    file_format_support["docx"] = True
    print("Supporto Word (.docx) attivato")
except ImportError:
    missing_libraries.append("python-docx")
    print("Supporto Word (.docx) non disponibile")

try:
    import PyPDF2
    file_format_support["pdf"] = True
    print("Supporto PDF attivato")
except ImportError:
    missing_libraries.append("PyPDF2")
    print("Supporto PDF non disponibile")

try:
    import pptx
    file_format_support["pptx"] = True
    print("Supporto PowerPoint attivato")
except ImportError:
    missing_libraries.append("python-pptx")
    print("Supporto PowerPoint non disponibile")

try:
    import openpyxl
    file_format_support["excel"] = True
    print("Supporto Excel attivato")
except ImportError:
    missing_libraries.append("openpyxl")
    print("Supporto Excel non disponibile")

try:
    from striprtf.striprtf import rtf_to_text
    file_format_support["rtf"] = True
    print("Supporto RTF attivato")
except ImportError:
    missing_libraries.append("striprtf")
    print("Supporto RTF non disponibile")

try:
    import odfdo
    file_format_support["odt"] = True
    print("Supporto ODT attivato (libreria odfdo)")
except ImportError:
    try:
        from odf import opendocument, text, teletype
        file_format_support["odt"] = True
        print("Supporto ODT attivato (libreria odf)")
    except ImportError:
        missing_libraries.append("odfdo")
        print("Supporto ODT non disponibile")

class FileSearchApp:
    def __init__(self, root):
        self.root = root
        self.root.title("File Search Tool.. Nucleo Perugia")
        self.root.geometry("1300x850")
        
        # Inizializza le variabili per data/ora e utente
        self.datetime_var = StringVar()
        self.user_var = StringVar(value=getpass.getuser())
        
        # Variabili
        self.search_content = BooleanVar(value=False)
        self.search_path = StringVar()
        self.keywords = StringVar()
        self.search_results = []
        self.search_files = BooleanVar(value=True)
        self.search_folders = BooleanVar(value=True)
        self.ignore_hidden = BooleanVar(value=True)
        self.is_searching = False
        self.progress_queue = queue.Queue()
        self.search_executor = None
        
        # Variabili aggiuntive per i miglioramenti
        self.stop_search = False
        self.max_depth = 0  # 0 = illimitato
        self.last_search_params = {}
        self.search_history = []
        self.advanced_filters = {
            "size_min": 0,
            "size_max": 0,
            "date_min": None,
            "date_max": None,
            "extensions": []
        }
        
        # Variabili per limiti di tempo e altre ottimizzazioni
        self.timeout_enabled = BooleanVar(value=False)
        self.timeout_seconds = IntVar(value=60)  # Default 60 secondi
        self.max_files_to_check = IntVar(value=10000)  # Limite numero di file da controllare
        self.max_results = IntVar(value=1000)  # Limite numero di risultati
        self.chunk_size = 8192  # Grandezza del chunk per la lettura dei file
        self.max_file_size_mb = IntVar(value=100)  # Dimensione massima file da analizzare (in MB)
        self.worker_threads = IntVar(value=4)  # Numero di worker threads per elaborazione parallela
        self.use_indexing = BooleanVar(value=True)  # Usa indicizzazione per velocizzare ricerche future
        self.search_index = {}  # Dizionario per indicizzare file e contenuti
        
        # Info utente e datetime
        self.current_user = getpass.getuser()
        self.datetime_var = StringVar()
        self.update_datetime()
        self.create_widgets()

        # Verifica le librerie e mostra notifica se necessario
        self.check_and_notify_missing_libraries()
        self.debug_mode = True
        
        # Registra handler per CTRL+C
        self.register_interrupt_handler()
    
    def register_interrupt_handler(self):
        """Registra il gestore degli interrupt (CTRL+C)"""
        def handle_interrupt(sig, frame):
            if self.is_searching:
                self.stop_search_process()
            else:
                self.root.quit()
        
        signal.signal(signal.SIGINT, handle_interrupt)

    def log_debug(self, message):
        """Funzione per logging, stampa solo quando debug_mode è True"""
        if self.debug_mode:
            print(f"[DEBUG] {message}")

    def check_and_notify_missing_libraries(self):
        """Verifica e notifica l'utente di eventuali librerie mancanti"""
        missing = []
        
        if not file_format_support["docx"]:
            missing.append("python-docx (per file Word)")
        if not file_format_support["pdf"]: 
            missing.append("PyPDF2 (per file PDF)")
        if not file_format_support["pptx"]:
            missing.append("python-pptx (per file PowerPoint)")
        if not file_format_support["excel"]:
            missing.append("openpyxl (per file Excel)")
        if not file_format_support["rtf"]:
            missing.append("striprtf (per file RTF)")
        if not file_format_support["odt"]:
            missing.append("odfdo (per file OpenDocument)")
        
        if missing:
            message = "Alcune funzionalità di ricerca nei contenuti sono disabilitate.\n\n"
            message += "Per abilitare il supporto completo ai vari formati di file, installa le seguenti librerie:\n\n"
            
            for lib in missing:
                message += f"- {lib}\n"
            
            message += "\nPuoi installarle con il comando:\n"
            message += "pip install " + " ".join([lib.split(" ")[0] for lib in missing])
            
            # Mostra la notifica dopo un breve ritardo per permettere all'UI di caricarsi
            self.root.after(1000, lambda: messagebox.showinfo("Librerie opzionali mancanti", message))

    def update_datetime(self):
        current_time = datetime.now().strftime('%d-%m-%Y %H:%M:%S')
        self.datetime_var.set(f"Data: {current_time} | Utente: {self.current_user}")
        self.root.after(1000, self.update_datetime)

    def browse_directory(self):
        directory = filedialog.askdirectory()
        if directory:
            self.search_path.set(directory)
    def optimize_system_search(self, path):
        """Ottimizza la ricerca per percorsi di sistema come C:/ impostando parametri appropriati"""
        if path.lower() in ["c:/", "c:\\", "d:/", "d:\\"]:
            # Salva i parametri attuali
            original_params = {
                "max_files": self.max_files_to_check.get(),
                "worker_threads": self.worker_threads.get()
            }
            
            # Applica parametri ottimizzati
            self.max_files_to_check.set(1000000)  # Aumenta il limite di file
            self.worker_threads.set(min(8, os.cpu_count() or 4))  # Aumenta i thread di lavoro
            
            # Notifica l'utente
            messagebox.showinfo(
                "Ricerca di sistema",
                "Stai avviando una ricerca su un intero disco di sistema.\n\n"
                "Per ottimizzare la ricerca, sono stati temporaneamente modificati alcuni parametri "
                "per consentire una scansione più approfondita.\n\n"
                "La ricerca potrebbe richiedere tempo e risorse significative."
            )
            
            return original_params
        return None
    def start_search(self):
        # Pulisci risultati precedenti
        for item in self.results_list.get_children():
            self.results_list.delete(item)
        
        if not self.search_path.get() or not self.keywords.get():
            messagebox.showerror("Errore", "Inserisci directory e parole chiave")
            return
        
        # Reset per la nuova ricerca
        self.stop_search = False
        self.stop_button["state"] = "normal"
        original_params = self.optimize_system_search(self.search_path.get())

        # Aggiorna l'orario di avvio e resetta l'orario di fine
        current_time = datetime.now().strftime('%H:%M')
        self.start_time_label.config(text=current_time)
        self.end_time_label.config(text="--:--")

        # Salva i parametri di ricerca
        self.last_search_params = {
            "path": self.search_path.get(),
            "keywords": self.keywords.get(),
            "search_files": self.search_files.get(),
            "search_folders": self.search_folders.get(),
            "search_content": self.search_content.get()
        }
        
        # Aggiungi alla cronologia di ricerca se non già presente
        if self.keywords.get() and self.keywords.get() not in [h["keywords"] for h in self.search_history]:
            self.search_history.append(self.last_search_params.copy())
            if len(self.search_history) > 10:  # Mantieni solo le ultime 10 ricerche
                self.search_history.pop(0)
        
        self.is_searching = True
        self.search_button["state"] = "disabled"
        self.progress_bar["value"] = 0
        self.status_label["text"] = "Ricerca in corso..."
        
        # Aggiorna il valore della profondità massima
        try:
            self.max_depth = int(self.depth_spinbox.get())
        except ValueError:
            self.max_depth = 0  # Valore predefinito se non valido
        
        # Ottieni le parole chiave di ricerca
        search_terms = [term.strip() for term in self.keywords.get().split(',') if term.strip()]
            
        # Avvia la ricerca in un thread separato
        self.search_results = []  # Resetta i risultati
        search_thread = threading.Thread(target=self._search_thread, 
                                        args=(self.search_path.get(), search_terms, self.search_content.get()))
        search_thread.daemon = True
        search_thread.start()
        
        # Avvia l'aggiornamento della progress bar
        self.update_progress()
        # Salva original_params come attributo per ripristinarli dopo la ricerca
        if original_params:
            self.original_system_search_params = original_params

    def _search_thread(self, path, keywords, search_content):
        """Thread per la ricerca file"""
        try:
            # Inizializza i contatori di file e directory esaminati e il tempo di inizio
            files_checked = 0
            dirs_checked = 0
            start_time = time.time()
            timeout = self.timeout_seconds.get() if self.timeout_enabled.get() else None
            
            # Determina se si tratta di una ricerca completa del sistema (C:/ o simile)
            is_system_search = path.lower() in ["c:/", "c:\\", "d:/", "d:\\"] or path in [os.path.abspath("/")]
            
            # Per ricerche di sistema, adatta automaticamente i parametri se necessario
            if is_system_search and self.max_depth == 0:
                # Informa l'utente che la ricerca potrebbe richiedere molto tempo
                self.progress_queue.put(("status", "Ricerca completa del sistema - potrebbe richiedere molto tempo"))
                
                # Temporaneamente aumenta i limiti per la ricerca di sistema
                original_max_files = self.max_files_to_check.get()
                self.max_files_to_check.set(1000000)  # Un milione di file
                
                # Disabilita temporaneamente il timeout se era breve
                original_timeout = timeout
                if timeout and timeout < 3600:  # Se il timeout è meno di un'ora
                    timeout = 3600  # Imposta a un'ora
                    
                # Avviso all'utente
                self.progress_queue.put(("status", "Ricerca completa avviata - parametri adattati per ricerca approfondita"))
            
            # Crea un executor per processare i file in parallelo
            max_workers = self.worker_threads.get()
            self.search_executor = concurrent.futures.ThreadPoolExecutor(max_workers=max_workers)
            futures = []
            
            # Insieme per tenere traccia delle cartelle visitate (evita loop infiniti con symlink)
            visited_dirs = set()
            
            # Funzione per elaborare un file
            def process_file(file_path, keywords):
                if self.stop_search:
                    return None
                
                try:
                    # Verifica filtri di dimensione
                    file_size = os.path.getsize(file_path)
                    if (self.advanced_filters["size_min"] > 0 and file_size < self.advanced_filters["size_min"]) or \
                    (self.advanced_filters["size_max"] > 0 and file_size > self.advanced_filters["size_max"]):
                        return None
                    
                    # Verifica filtri di data
                    if self.advanced_filters["date_min"] or self.advanced_filters["date_max"]:
                        mod_time = datetime.fromtimestamp(os.path.getmtime(file_path))
                        mod_date_str = mod_time.strftime("%d-%m-%Y")
                        
                        if self.advanced_filters["date_min"]:
                            min_date = datetime.strptime(self.advanced_filters["date_min"], "%d-%m-%Y")
                            if mod_time < min_date:
                                return None
                                
                        if self.advanced_filters["date_max"]:
                            max_date = datetime.strptime(self.advanced_filters["date_max"], "%d-%m-%Y")
                            if mod_time > max_date:
                                return None
                    
                    # Verifica filtri estensione
                    if self.advanced_filters["extensions"] and not any(file_path.lower().endswith(ext.lower()) 
                                                                for ext in self.advanced_filters["extensions"]):
                        return None
                    
                    # Verifica corrispondenza nel nome file
                    filename = os.path.basename(file_path)
                    if any(keyword.lower() in filename.lower() for keyword in keywords):
                        return self.create_file_info(file_path)
                    
                    # Verifica contenuto se richiesto
                    if search_content and self.should_search_content(file_path):
                        max_size_bytes = self.max_file_size_mb.get() * 1024 * 1024
                        
                        # Salta file troppo grandi
                        if file_size > max_size_bytes:
                            self.log_debug(f"File {file_path} troppo grande per l'analisi del contenuto")
                            return None
                            
                        content = self.get_file_content(file_path)
                        if content and any(keyword.lower() in content.lower() for keyword in keywords):
                            return self.create_file_info(file_path)
                    
                    return None
                    
                except Exception as e:
                    self.log_debug(f"Errore durante l'elaborazione del file {file_path}: {str(e)}")
                    return None
            
            # Funzione per visitare una directory
            def visit_directory(directory, current_depth=0):
                # CORREZIONE: Dichiarazioni nonlocal all'inizio della funzione
                nonlocal dirs_checked, files_checked, visited_dirs
                
                if self.stop_search:
                    return
                    
                # Verifica timeout
                if timeout and time.time() - start_time > timeout:
                    self.progress_queue.put(("timeout", "Timeout raggiunto"))
                    return
                
                # Verifica limite di profondità (0 = illimitato)
                if self.max_depth > 0 and current_depth > self.max_depth:
                    return
                    
                # Evita di visitare directory già visitate (gestisce symlinks circolari)
                try:
                    real_path = os.path.realpath(directory)
                    if real_path in visited_dirs:
                        return
                    visited_dirs.add(real_path)
                except Exception:
                    # Se non è possibile ottenere il percorso reale, usa quello originale
                    if directory in visited_dirs:
                        return
                    visited_dirs.add(directory)
            
                try:
                    # Incrementa il contatore delle cartelle analizzate
                    dirs_checked += 1
                    
                    # Aggiorna lo stato con il percorso corrente ogni 10 directory
                    if dirs_checked % 10 == 0:
                        elapsed_time = time.time() - start_time
                        self.progress_queue.put(("status", 
                            f"Analisi: {directory} (Cartelle: {dirs_checked}, File: {files_checked}, Tempo: {int(elapsed_time)}s)"))
                    
                    # Ottieni la lista delle cartelle e file
                    try:
                        items = os.listdir(directory)
                    except PermissionError:
                        self.log_debug(f"Permesso negato per la directory {directory}")
                        
                        # NUOVO: Per percorsi critici, specialmente su C:/, tenta di esplorare sottodirectory note
                        if directory.lower() in ["c:/", "c:\\", "d:/", "d:\\"]:
                            # Aggiungi manualmente i percorsi utente e altri percorsi importanti
                            system_paths_to_try = [
                                os.path.join(directory, "Users"),
                                os.path.join(directory, "Documents and Settings"),  # Per compatibilità con sistemi più vecchi
                                os.path.join(directory, "Program Files"),
                                os.path.join(directory, "Program Files (x86)"),
                                os.path.join(directory, "ProgramData"),
                                os.path.join(directory, "Windows")
                            ]
                            
                            # Notifica l'utente che stiamo tentando di accedere a percorsi speciali
                            self.progress_queue.put(("status", "Tentativo di accesso a cartelle speciali..."))
                            
                            for special_path in system_paths_to_try:
                                if os.path.exists(special_path) and os.path.isdir(special_path):
                                    # Tenta di esplorare queste directory importanti
                                    visit_directory(special_path, current_depth + 1)
                                    
                            # Se siamo in C:/Users, tenta di accedere a ciascuna cartella utente
                            if directory.lower() in ["c:/users", "c:\\users"]:
                                try:
                                    user_folders = os.listdir(directory)
                                    for user_folder in user_folders:
                                        user_path = os.path.join(directory, user_folder)
                                        if os.path.isdir(user_path):
                                            # Per ciascun utente, esplora le sottocartelle comuni
                                            important_user_folders = [
                                                "Desktop", "Documents", "Downloads", "Pictures", 
                                                "Videos", "Music", "OneDrive"
                                            ]
                                            
                                            for folder in important_user_folders:
                                                folder_path = os.path.join(user_path, folder)
                                                if os.path.exists(folder_path) and os.path.isdir(folder_path):
                                                    visit_directory(folder_path, current_depth + 1)
                                except:
                                    self.log_debug(f"Impossibile elencare le cartelle degli utenti in {directory}")
                        
                        return
                    except Exception as e:
                        self.log_debug(f"Errore nell'accesso alla directory {directory}: {str(e)}")
                        return
                    
                    # Prima processa tutte le directory, poi i file (priorità alla profondità)
                    directories = []
                    for item in items:
                        if self.stop_search:
                            return
                            
                        item_path = os.path.join(directory, item)
                        
                        # Salta file/cartelle nascosti se richiesto
                        try:
                            if self.ignore_hidden.get() and (item.startswith('.') or 
                                                    (os.name == 'nt' and os.path.exists(item_path) and 
                                                        os.stat(item_path).st_file_attributes & 2)):
                                continue
                        except:
                            continue  # Se non riesce a verificare, salta
                        
                        # Processa le cartelle separatamente per dare priorità alla profondità
                        try:
                            if os.path.isdir(item_path):
                                directories.append(item_path)
                                
                                # Verifica corrispondenza nome cartella
                                if self.search_folders.get():
                                    if any(keyword.lower() in item.lower() for keyword in keywords):
                                        folder_info = self.create_folder_info(item_path)
                                        self.search_results.append(folder_info)
                        except:
                            continue
                                
                    # Processa i file
                    for item in items:
                        if self.stop_search:
                            return
                            
                        item_path = os.path.join(directory, item)
                        
                        # Salta le directory (già processate)
                        try:
                            if os.path.isdir(item_path):
                                continue
                        except:
                            continue
                            
                        # Processa i file
                        if self.search_files.get():
                            try:
                                # Verifica limite file
                                files_checked += 1
                                if files_checked > self.max_files_to_check.get():
                                    self.stop_search = True
                                    self.progress_queue.put(("status", 
                                        f"Limite di {self.max_files_to_check.get()} file controllati raggiunto. "
                                        f"Aumenta il limite nelle opzioni per cercare più file."))
                                    return
                                    
                                # Invia il file all'executor per elaborazione parallela
                                future = self.search_executor.submit(process_file, item_path, keywords)
                                futures.append(future)
                                
                                # Aggiorna progresso periodicamente
                                if files_checked % 50 == 0:
                                    elapsed_time = time.time() - start_time
                                    self.progress_queue.put(("status", 
                                        f"Analizzati {files_checked} file in {dirs_checked} cartelle (tempo: {int(elapsed_time)}s)"))
                                    self.progress_queue.put(("progress", 
                                        min(90, int(files_checked / self.max_files_to_check.get() * 100))))
                            except:
                                continue
                    
                    # Esplorazione ricorsiva delle directory trovate
                    for dir_path in directories:
                        if self.stop_search:
                            return
                        visit_directory(dir_path, current_depth + 1)
                        
                except PermissionError:
                    self.log_debug(f"Permesso negato per la directory {directory}")
                except Exception as e:
                    self.log_debug(f"Errore durante l'analisi della directory {directory}: {str(e)}")
            
            # Aggiorna lo stato iniziale
            self.progress_queue.put(("status", f"Inizio ricerca in: {path} (Profondità: {'illimitata' if self.max_depth == 0 else self.max_depth})"))
            
            # Avvia la ricerca
            visit_directory(path)
            
            # Ripristina i parametri originali se erano stati modificati
            if is_system_search and self.max_depth == 0:
                self.max_files_to_check.set(original_max_files)
            
            # Aggiorna lo stato finale di analisi
            self.progress_queue.put(("status", f"Elaborazione risultati... (analizzati {files_checked} file in {dirs_checked} cartelle)"))
            
            # Raccoglie i risultati dalle future
            completed = 0
            for future in concurrent.futures.as_completed(futures):
                if self.stop_search:
                    break
                    
                result = future.result()
                if result:
                    self.search_results.append(result)
                
                completed += 1
                if completed % 100 == 0:
                    progress = 90 + min(10, int((completed / max(1, len(futures))) * 10))
                    self.progress_queue.put(("progress", progress))
                    self.progress_queue.put(("status", f"Elaborati {completed}/{len(futures)} file..."))
            
            # Completa la ricerca
            self.search_executor.shutdown()
            self.search_executor = None
            
            # Ripristina i parametri originali se erano stati modificati per la ricerca di sistema
            if hasattr(self, 'original_system_search_params'):
                self.max_files_to_check.set(self.original_system_search_params["max_files"])
                self.worker_threads.set(self.original_system_search_params["worker_threads"])
                delattr(self, 'original_system_search_params')

            # Riporta il risultato finale
            elapsed_time = time.time() - start_time
            self.progress_queue.put(("status", 
                f"Ricerca completata! Analizzati {files_checked} file in {dirs_checked} cartelle in {int(elapsed_time)} secondi."))
            
            # Ordina i risultati per tipo e nome
            self.search_results.sort(key=lambda x: (x[0], x[1]))
            
            self.log_debug(f"Ricerca completata. Trovati {len(self.search_results)} risultati")
            self.progress_queue.put(("complete", "Ricerca completata"))
            
        except Exception as e:
            error_msg = f"Si è verificato un errore durante la ricerca: {str(e)}\n{traceback.format_exc()}"
            self.log_debug(error_msg)
            self.progress_queue.put(("error", error_msg))

    def create_file_info(self, file_path):
        """Crea le informazioni del file per la visualizzazione"""
        try:
            file_size = os.path.getsize(file_path)
            modified_time = datetime.fromtimestamp(os.path.getmtime(file_path))
            created_time = datetime.fromtimestamp(os.path.getctime(file_path))
            file_name = os.path.basename(file_path)
            file_extension = os.path.splitext(file_name)[1].lower()
            
            # Determina il tipo di file
            mime_type, _ = mimetypes.guess_type(file_path)
            if mime_type:
                file_type = mime_type.split('/')[0].capitalize()
                if file_type == "Application":
                    if "pdf" in mime_type:
                        file_type = "PDF"
                    elif "word" in mime_type or file_extension == ".docx" or file_extension == ".doc":
                        file_type = "Word"
                    elif "excel" in mime_type or file_extension in [".xlsx", ".xls"]:
                        file_type = "Excel"
                    elif "powerpoint" in mime_type or file_extension in [".pptx", ".ppt"]:
                        file_type = "PowerPoint"
                    else:
                        file_type = "Documento"
            else:
                # Fallback basato sull'estensione
                if file_extension in ['.txt', '.md', '.rtf']:
                    file_type = "Testo"
                elif file_extension in ['.jpg', '.jpeg', '.png', '.gif', '.bmp']:
                    file_type = "Immagine"
                elif file_extension in ['.mp3', '.wav', '.ogg', '.flac']:
                    file_type = "Audio"
                elif file_extension in ['.mp4', '.avi', '.mkv', '.mov']:
                    file_type = "Video"
                elif file_extension in ['.exe', '.dll', '.bat']:
                    file_type = "Eseguibile"
                else:
                    file_type = "File"
            
            # Formatta dimensione file
            if file_size < 1024:
                size_str = f"{file_size} B"
            elif file_size < 1024 * 1024:
                size_str = f"{file_size / 1024:.1f} KB"
            else:
                size_str = f"{file_size / (1024 * 1024):.1f} MB"
            
            return (
                file_type,
                file_name,
                size_str,
                modified_time.strftime('%d/%m/%Y %H:%M'),
                created_time.strftime('%d/%m/%Y %H:%M'),
                file_path
            )
        except Exception as e:
            self.log_debug(f"Errore nel creare le informazioni del file {file_path}: {str(e)}")
            return (
                "File",
                os.path.basename(file_path),
                "N/A",
                "N/A",
                "N/A",
                file_path
            )

    def create_folder_info(self, folder_path):
        """Crea le informazioni della cartella per la visualizzazione"""
        try:
            modified_time = datetime.fromtimestamp(os.path.getmtime(folder_path))
            created_time = datetime.fromtimestamp(os.path.getctime(folder_path))
            folder_name = os.path.basename(folder_path)
            
            return (
                "Directory",
                folder_name,
                "",  # Le cartelle non hanno dimensione
                modified_time.strftime('%d/%m/%Y %H:%M'),
                created_time.strftime('%d/%m/%Y %H:%M'),
                folder_path
            )
        except Exception as e:
            self.log_debug(f"Errore nel creare le informazioni della cartella {folder_path}: {str(e)}")
            return (
                "Directory",
                os.path.basename(folder_path),
                "",
                "N/A",
                "N/A",
                folder_path
            )
            
    def should_search_content(self, file_path):
        """Determina se il contenuto del file dovrebbe essere analizzato"""
        ext = os.path.splitext(file_path)[1].lower()
        
        # Verifica direttamente i tipi di file supportati per la ricerca nei contenuti
        return (
            (ext == '.txt') or
            (ext == '.md') or
            (ext == '.csv') or
            (ext == '.html') or
            (ext == '.htm') or
            (ext == '.xml') or
            (ext == '.json') or
            (ext == '.log') or
            (ext in ['.doc', '.docx'] and file_format_support["docx"]) or
            (ext == '.pdf' and file_format_support["pdf"]) or
            (ext in ['.ppt', '.pptx'] and file_format_support["pptx"]) or
            (ext in ['.xls', '.xlsx'] and file_format_support["excel"]) or
            (ext == '.rtf' and file_format_support["rtf"]) or
            (ext == '.odt' and file_format_support["odt"])
        )

    def get_file_content(self, file_path):
        """Ottiene il contenuto del file in base all'estensione"""
        try:
            ext = os.path.splitext(file_path)[1].lower()
            
            # File di testo semplice
            if ext in ['.txt', '.md', '.csv', '.html', '.htm', '.xml', '.json', '.log']:
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        return f.read()
                except UnicodeDecodeError:
                    # Fallback su altre codifiche
                    try:
                        with open(file_path, 'r', encoding='latin-1') as f:
                            return f.read()
                    except:
                        self.log_debug(f"Impossibile leggere il file {file_path} con le codifiche standard")
                        return ""
            
            # Word document
            elif ext in ['.docx', '.doc'] and file_format_support["docx"]:
                try:
                    doc = docx.Document(file_path)
                    return "\n".join([para.text for para in doc.paragraphs])
                except Exception as e:
                    self.log_debug(f"Errore nella lettura del documento Word {file_path}: {str(e)}")
                    return ""
            
            # PDF
            elif ext == '.pdf' and file_format_support["pdf"]:
                try:
                    content = []
                    with open(file_path, 'rb') as f:
                        reader = PyPDF2.PdfReader(f)
                        for page_num in range(min(10, len(reader.pages))):  # Limite di 10 pagine per prestazioni
                            page = reader.pages[page_num]
                            content.append(page.extract_text())
                    return "\n".join(content)
                except Exception as e:
                    self.log_debug(f"Errore nella lettura del PDF {file_path}: {str(e)}")
                    return ""
            
            # PowerPoint
            elif ext in ['.pptx', '.ppt'] and file_format_support["pptx"]:
                try:
                    prs = pptx.Presentation(file_path)
                    text = []
                    for slide in prs.slides:
                        for shape in slide.shapes:
                            if hasattr(shape, "text"):
                                text.append(shape.text)
                    return "\n".join(text)
                except Exception as e:
                    self.log_debug(f"Errore nella lettura della presentazione {file_path}: {str(e)}")
                    return ""
            
            # Excel
            elif ext in ['.xlsx', '.xls'] and file_format_support["excel"]:
                try:
                    wb = openpyxl.load_workbook(file_path, read_only=True, data_only=True)
                    texts = []
                    for sheet_name in wb.sheetnames[:5]:  # Limita a 5 fogli per prestazioni
                        sheet = wb[sheet_name]
                        for row in sheet.iter_rows(max_row=100):  # Limita a 100 righe per prestazioni
                            row_texts = [str(cell.value) for cell in row if cell.value is not None]
                            texts.append(" ".join(row_texts))
                    return "\n".join(texts)
                except Exception as e:
                    self.log_debug(f"Errore nella lettura del foglio Excel {file_path}: {str(e)}")
                    return ""
            
            # RTF
            elif ext == '.rtf' and file_format_support["rtf"]:
                try:
                    with open(file_path, 'r', encoding='latin-1') as f:
                        rtf_text = f.read()
                    return rtf_to_text(rtf_text)
                except Exception as e:
                    self.log_debug(f"Errore nella lettura del file RTF {file_path}: {str(e)}")
                    return ""
                    
            # ODT (OpenDocument Text)
            elif ext == '.odt' and file_format_support["odt"]:
                try:
                    # Prova prima con odfdo
                    if 'odfdo' in sys.modules:
                        doc = odfdo.Document(file_path)
                        return doc.get_formatted_text()
                    # Fallback su odf
                    else:
                        textdoc = opendocument.load(file_path)
                        allparas = textdoc.getElementsByType(text.P)
                        return "\n".join([teletype.extractText(para) for para in allparas])
                except Exception as e:
                    self.log_debug(f"Errore nella lettura del file ODT {file_path}: {str(e)}")
                    return ""
            return ""  # Tipo di file non supportato
        except Exception as e:
            self.log_debug(f"Errore generale nella lettura del file {file_path}: {str(e)}")
            return ""
        
    def update_progress(self):
        if self.is_searching:
            try:
                while True:
                    progress_type, value = self.progress_queue.get_nowait()
                    if progress_type == "progress":
                        self.progress_bar["value"] = value
                    elif progress_type == "status":
                        self.status_label["text"] = value
                    elif progress_type == "complete":
                        self.is_searching = False
                        self.search_button["state"] = "normal"
                        self.stop_button["state"] = "disabled"
                        
                        # Aggiorna la lista dei risultati
                        self.update_results_list()
                        
                        if len(self.search_results) == 0:
                            self.status_label["text"] = "Nessun file trovato per la ricerca effettuata"
                            self.root.after(100, lambda: messagebox.showinfo("Ricerca completata", "Nessun file trovato per la ricerca effettuata"))
                        else:
                            self.status_label["text"] = f"Ricerca completata! Trovati {len(self.search_results)} risultati."
                        
                        self.progress_bar["value"] = 100
                        current_time = datetime.now().strftime('%H:%M')
                        self.end_time_label.config(text=current_time)
                        return
                    elif progress_type == "error":
                        self.is_searching = False
                        self.search_button["state"] = "normal"
                        self.stop_button["state"] = "disabled"
                        current_time = datetime.now().strftime('%H:%M')
                        self.end_time_label.config(text=current_time)
                        messagebox.showerror("Errore", value)
                        return
                    elif progress_type == "timeout":
                        self.is_searching = False
                        self.search_button["state"] = "normal"
                        self.stop_button["state"] = "disabled"
                        self.update_results_list()  # Mostra i risultati trovati fino a quel momento
                        current_time = datetime.now().strftime('%H:%M')
                        self.end_time_label.config(text=current_time)
                        messagebox.showinfo("Timeout", "La ricerca è stata interrotta per timeout. Verranno mostrati i risultati parziali trovati.")
                        return
            except queue.Empty:
                pass
                    
            self.root.after(100, self.update_progress)
            
    def stop_search_process(self):
        """Ferma il processo di ricerca in corso"""
        self.stop_search = True
        self.status_label["text"] = "Interrompendo la ricerca..."
        current_time = datetime.now().strftime('%H:%M')
        self.end_time_label.config(text=current_time)
        
        # Chiudi l'executor se esiste
        if self.search_executor:
            self.search_executor.shutdown(wait=False, cancel_futures=True)
        
        # Aggiorna l'orario di fine quando la ricerca viene interrotta
        self.search_button["state"] = "normal"
        self.stop_button["state"] = "disabled"

    def update_results_list(self):
        """Aggiorna la lista dei risultati con i risultati trovati"""
        # Pulisci la lista attuale
        for item in self.results_list.get_children():
            self.results_list.delete(item)
            
        # Aggiungi i risultati alla lista
        for result in self.search_results:
            item_type, name, size, modified, created, path = result
            
            # Applica stile in base al tipo di elemento
            if item_type == "Directory":
                tags = ("directory",)
            else:
                tags = ("file",)
                
            self.results_list.insert("", "end", values=result, tags=tags)
            
        # Aggiorna lo stato
        self.status_label["text"] = f"Trovati {len(self.search_results)} risultati"
        
    def update_theme_colors(self):
        """Aggiorna i colori del tema per evidenziare cartelle e file"""
        style = ttk.Style()
        
        # Colori per cartelle
        style.configure("Treeview", rowheight=25)
        
        # Configurazione tag per directory
        self.results_list.tag_configure("directory", background="#e6f2ff")
        
        # Configurazione tag per file
        self.results_list.tag_configure("file", background="#ffffff")

    def copy_selected(self):
        """Copia i file selezionati in una directory di destinazione"""
        selected_items = self.results_list.selection()
        if not selected_items:
            messagebox.showwarning("Attenzione", "Seleziona almeno un elemento da copiare")
            return
            
        # Chiedi la directory di destinazione
        dest_dir = filedialog.askdirectory(title="Seleziona la cartella di destinazione")
        if not dest_dir:
            return
            
        # Prepara variabili per tracciare l'avanzamento
        total = len(selected_items)
        copied = 0
        failed = 0
        skipped = 0
        
        try:
            for item in selected_items:
                values = self.results_list.item(item)['values']
                item_type, _, _, _, _, source_path = values
                
                # Ottieni il nome dell'elemento senza il percorso completo
                basename = os.path.basename(source_path)
                dest_path = os.path.join(dest_dir, basename)
                
                try:
                    if item_type == "Directory":
                        # Se la cartella esiste già nella destinazione
                        if os.path.exists(dest_path):
                            if messagebox.askyesno("Cartella esistente", 
                                                f"La cartella {basename} esiste già. Vuoi sovrascriverla?"):
                                # Elimina la cartella esistente
                                shutil.rmtree(dest_path)
                            else:
                                skipped += 1
                                continue
                                
                        # Copia ricorsiva della cartella
                        shutil.copytree(source_path, dest_path)
                        copied += 1
                    else:
                        # Se il file esiste già nella destinazione
                        if os.path.exists(dest_path):
                            if messagebox.askyesno("File esistente", 
                                                f"Il file {basename} esiste già. Vuoi sovrascriverlo?"):
                                # Continua con la sovrascrittura
                                pass
                            else:
                                skipped += 1
                                continue
                                
                        # Copia il file
                        shutil.copy2(source_path, dest_path)
                        copied += 1
                        
                except Exception as e:
                    failed += 1
                    self.log_debug(f"Errore durante la copia di {source_path}: {str(e)}")
                    
                # Aggiorna la barra di avanzamento
                progress = ((copied + failed + skipped) / total) * 100
                self.progress_bar["value"] = progress
                self.status_label["text"] = f"Copiati {copied}/{total} elementi..."
                self.root.update()
                
            # Messaggio di completamento
            if failed > 0:
                messagebox.showwarning("Copia completata con errori", 
                                    f"Copiati: {copied}\nSaltati: {skipped}\nFalliti: {failed}")
            else:
                messagebox.showinfo("Copia completata", 
                                 f"Copiati con successo: {copied}\nSaltati: {skipped}")
                
        except Exception as e:
            messagebox.showerror("Errore", f"Si è verificato un errore durante l'operazione: {str(e)}")
            
        finally:
            self.progress_bar["value"] = 0
            self.status_label["text"] = "In attesa..."

    def compress_selected(self):
        selected_items = self.results_list.selection()
        if not selected_items:
            messagebox.showwarning("Attenzione", "Seleziona almeno un elemento da comprimere")
            return
            
        zip_name = Querybox.get_string(
            prompt="Inserisci il nome del file ZIP (senza estensione):",
            title="Nome file ZIP",
            initialvalue="archivio"
        )
        
        if not zip_name:
            return
            
        zip_path = filedialog.asksaveasfilename(
            defaultextension=".zip",
            initialfile=f"{zip_name}.zip",
            filetypes=[("ZIP files", "*.zip")],
            title="Salva file ZIP"
        )
        
        if not zip_path:
            return
            
        # Raccogli tutti i file delle cartelle selezionate
        files_in_folders = set()
        folder_paths = []
        single_files = []
        
        # Prima fase: raccogli informazioni su cartelle e file
        for item in selected_items:
            values = self.results_list.item(item)['values']
            item_type, _, _, _, _, source_path = values
            
            if item_type == "Directory":
                folder_paths.append(source_path)
                # Raccogli tutti i file nelle cartelle selezionate
                for root, _, files in os.walk(source_path):
                    for file in files:
                        full_path = os.path.join(root, file)
                        files_in_folders.add(os.path.abspath(full_path))
            else:
                single_files.append(source_path)
        
        # Filtra i file singoli che sono già presenti nelle cartelle
        filtered_single_files = [f for f in single_files if os.path.abspath(f) not in files_in_folders]
        
        total_items = len(folder_paths) + len(filtered_single_files)
        processed = 0
        
        try:
            with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                # Prima comprimi le cartelle
                for folder_path in folder_paths:
                    base_folder = os.path.basename(folder_path)
                    for root, _, files in os.walk(folder_path):
                        for file in files:
                            file_path = os.path.join(root, file)
                            # Mantieni la struttura delle cartelle nel zip
                            rel_path = os.path.relpath(file_path, os.path.dirname(folder_path))
                            zipf.write(file_path, rel_path)
                    
                    processed += 1
                    progress = (processed / total_items) * 100
                    self.progress_bar["value"] = progress
                    self.status_label["text"] = f"Compressi {processed} di {total_items} elementi"
                    self.root.update()
                
                # Poi comprimi i file singoli (solo quelli non già presenti nelle cartelle)
                for file_path in filtered_single_files:
                    if os.path.exists(file_path):  # Verifica che il file esista ancora
                        zipf.write(file_path, os.path.basename(file_path))
                        
                    processed += 1
                    progress = (processed / total_items) * 100
                    self.progress_bar["value"] = progress
                    self.status_label["text"] = f"Compressi {processed} di {total_items} elementi"
                    self.root.update()
            
            # Prepara il messaggio di completamento
            skipped_files = len(single_files) - len(filtered_single_files)
            message = f"Compressione completata!\nFile salvato in: {zip_path}"
            if skipped_files > 0:
                message += f"\n{skipped_files} file saltati perché già presenti nelle cartelle"
                
            messagebox.showinfo("Completato", message)
            
        except Exception as e:
            messagebox.showerror("Errore", f"Errore durante la compressione: {str(e)}")
            
        finally:
            self.progress_bar["value"] = 0
            self.status_label["text"] = "In attesa..."

    def show_advanced_filters_dialog(self):
        """Mostra la finestra di dialogo per i filtri di ricerca avanzati"""
        dialog = ttk.Toplevel(self.root)
        dialog.title("Filtri avanzati")
        dialog.geometry("500x350")
        dialog.transient(self.root)
        dialog.grab_set()
        
        # Filtri dimensione
        size_frame = ttk.LabelFrame(dialog, text="Dimensione file")
        size_frame.pack(fill=X, padx=10, pady=5)
        
        ttk.Label(size_frame, text="Min (KB):").grid(row=0, column=0, padx=5, pady=5)
        min_size = ttk.Entry(size_frame, width=10)
        min_size.grid(row=0, column=1, padx=5, pady=5)
        min_size.insert(0, str(self.advanced_filters["size_min"] // 1024))
        
        ttk.Label(size_frame, text="Max (KB):").grid(row=0, column=2, padx=5, pady=5)
        max_size = ttk.Entry(size_frame, width=10)
        max_size.grid(row=0, column=3, padx=5, pady=5)
        max_size.insert(0, str(self.advanced_filters["size_max"] // 1024 if self.advanced_filters["size_max"] else 0))
        
        # Filtri data - FORMAT DD-MM-YYYY
        date_frame = ttk.LabelFrame(dialog, text="Data modifica (DD-MM-YYYY)")
        date_frame.pack(fill=X, padx=10, pady=5)
        
        ttk.Label(date_frame, text="Da:").grid(row=0, column=0, padx=5, pady=5)
        min_date = ttk.DateEntry(date_frame, dateformat="%d-%m-%Y")
        min_date.grid(row=0, column=1, padx=5, pady=5)
        
        ttk.Label(date_frame, text="A:").grid(row=0, column=2, padx=5, pady=5)
        max_date = ttk.DateEntry(date_frame, dateformat="%d-%m-%Y")
        max_date.grid(row=0, column=3, padx=5, pady=5)
        
        # Prepopola le date se disponibili
        if self.advanced_filters["date_min"]:
            min_date.entry.delete(0, "end")
            min_date.entry.insert(0, self.advanced_filters["date_min"])
                
        if self.advanced_filters["date_max"]:
            max_date.entry.delete(0, "end")
            max_date.entry.insert(0, self.advanced_filters["date_max"])
        
        # Filtri estensione
        ext_frame = ttk.LabelFrame(dialog, text="Estensioni file (separate da virgola)")
        ext_frame.pack(fill=X, padx=10, pady=5)
        example_label = ttk.Label(ext_frame, text="Inserisci una o più estensioni da ricercare. Esempio: .pdf, .dot", 
                       font=("", 8), foreground="gray")
        example_label.pack(anchor="w", padx=5)
        
        extensions = ttk.Entry(ext_frame)
        extensions.pack(fill=X, padx=5, pady=5)
        if self.advanced_filters["extensions"]:
            extensions.insert(0, ", ".join(self.advanced_filters["extensions"]))
        
        # Aggiungiamo un frame di debug per vedere i filtri correnti
        debug_frame = ttk.LabelFrame(dialog, text="Debug - Stato filtri correnti")
        debug_frame.pack(fill=X, padx=10, pady=5)
        
        debug_text = ttk.Text(debug_frame, height=3, width=50)
        debug_text.pack(fill=X, padx=5, pady=5)
        debug_text.insert("1.0", f"Data min: {self.advanced_filters['date_min']}\n")
        debug_text.insert("2.0", f"Data max: {self.advanced_filters['date_max']}\n")
        debug_text.insert("3.0", f"Extensions: {self.advanced_filters['extensions']}")
        debug_text.config(state="disabled")
        
        # Pulsante Salva
        def save_filters():
            try:
                # Analizza i filtri di dimensione
                min_kb = int(min_size.get() or 0)
                max_kb = int(max_size.get() or 0)
                self.advanced_filters["size_min"] = min_kb * 1024
                self.advanced_filters["size_max"] = max_kb * 1024
                
                # Ottieni le date nel formato DD-MM-YYYY
                min_date_value = min_date.entry.get().strip()
                max_date_value = max_date.entry.get().strip()
                
                print(f"DEBUG - Date inserite: min={min_date_value}, max={max_date_value}")
                
                # Validazione date
                if min_date_value:
                    try:
                        # Verifica formato corretto
                        datetime.strptime(min_date_value, "%d-%m-%Y")
                    except ValueError:
                        messagebox.showerror("Errore", "Formato data minima non valido. Usa DD-MM-YYYY")
                        return
                
                if max_date_value:
                    try:
                        # Verifica formato corretto
                        datetime.strptime(max_date_value, "%d-%m-%Y")
                    except ValueError:
                        messagebox.showerror("Errore", "Formato data massima non valido. Usa DD-MM-YYYY")
                        return
                
                # Verifica che la data minima non sia successiva alla data massima
                if min_date_value and max_date_value:
                    min_date_obj = datetime.strptime(min_date_value, "%d-%m-%Y")
                    max_date_obj = datetime.strptime(max_date_value, "%d-%m-%Y")
                    
                    if min_date_obj > max_date_obj:
                        messagebox.showerror("Errore", 
                                            "La data di inizio non può essere successiva alla data di fine")
                        return
                
                # Salva le date validate
                self.advanced_filters["date_min"] = min_date_value
                self.advanced_filters["date_max"] = max_date_value
                
                # Analizza le estensioni
                exts = [e.strip() for e in extensions.get().split(",") if e.strip()]
                self.advanced_filters["extensions"] = [f".{e.lstrip('.')}" for e in exts]
                
                print(f"Filtri salvati: {self.advanced_filters}")  # Debug info
                dialog.destroy()
                
            except ValueError:
                messagebox.showerror("Errore", "Inserisci valori numerici validi per le dimensioni")
        
        ttk.Button(dialog, text="Salva", command=save_filters).pack(pady=10)
        ttk.Button(dialog, text="Annulla", command=dialog.destroy).pack(pady=5)

        dialog.update_idletasks()  # Aggiorna la finestra per ottenere le dimensioni corrette
        width = dialog.winfo_width()
        height = dialog.winfo_height()
        x = (dialog.winfo_screenwidth() // 2) - (width // 2)
        y = (dialog.winfo_screenheight() // 2) - (height // 2)
        dialog.geometry(f"{width}x{height}+{x}+{y}")
        
        # Imposta una dimensione minima per la finestra
        dialog.minsize(500, 400)

    def create_widgets(self):
        # Frame principale che conterrà tutto tranne la barra di stato
        main_container = ttk.Frame(self.root)
        main_container.pack(fill=BOTH, expand=YES)
        
        # Frame principale per il contenuto
        main_frame = ttk.Frame(main_container, padding="10")
        main_frame.pack(fill=BOTH, expand=YES)
        
        # Aggiungi selezione tema
        theme_frame = ttk.Frame(main_frame)
        theme_frame.pack(fill=X, pady=5)
        
        ttk.Label(theme_frame, text="Tema:").pack(side=LEFT, padx=5)
        themes = ttk.Style().theme_names()
        theme_combobox = ttk.Combobox(theme_frame, values=themes, width=15)
        theme_combobox.pack(side=LEFT, padx=5)
        theme_combobox.current(themes.index("darkly"))
        theme_combobox.bind("<<ComboboxSelected>>", lambda e: [ttk.Style().theme_use(theme_combobox.get()),self.update_theme_colors()])
        
        # Sezione selezione directory
        path_frame = ttk.LabelFrame(main_frame, text="Directory di ricerca", padding="5")
        path_frame.pack(fill=X, pady=5)
       
        self.path_entry = ttk.Entry(path_frame, textvariable=self.search_path)
        example_label = ttk.Label(path_frame, text="Seleziona la directory per effettuare la ricerca dei file", 
                       font=("", 8), foreground="gray")
        example_label.pack(anchor="w", padx=5)
        self.path_entry.pack(side=LEFT, fill=X, expand=YES, padx=5)
        
        ttk.Button(path_frame, text="Sfoglia", command=self.browse_directory).pack(side=LEFT, padx=5)
        
        # Sezione keywords
        keyword_frame = ttk.LabelFrame(main_frame, text="Parole chiave", padding="5")
        keyword_frame.pack(fill=X, pady=5)

        # Aggiungi il tooltip sulla casella delle parole chiave
        example_label = ttk.Label(keyword_frame, text="Per la ricerca di più parole usa la virgola. Esempio: documento, fattura, contratto", 
                       font=("", 8), foreground="gray")
        example_label.pack(anchor="w", padx=5)

        # Crea l'entry delle parole chiave e salvala come attributo dell'istanza
        self.keyword_entry = ttk.Entry(keyword_frame, textvariable=self.keywords)
        self.keyword_entry.pack(fill=X, padx=5)
           
        # Opzioni di ricerca
        options_frame = ttk.LabelFrame(main_frame, text="Opzioni di ricerca", padding="5")
        options_frame.pack(fill=X, pady=5)
        example_label = ttk.Label(options_frame, text="Seleziona una o più opzioni per la ricerca", 
                       font=("", 8), foreground="gray")
        example_label.pack(anchor="w", padx=5)
        ttk.Checkbutton(options_frame, text="Cerca file", variable=self.search_files).pack(side=LEFT, padx=5)
        ttk.Checkbutton(options_frame, text="Cerca cartelle", variable=self.search_folders).pack(side=LEFT, padx=5)
        
        # Checkbox "Cerca nei contenuti" 
        content_checkbox = ttk.Checkbutton(options_frame, text="Cerca nei contenuti", 
                                  variable=self.search_content, 
                                  command=self.warn_content_search)
        content_checkbox.pack(side=LEFT, padx=5)
        self.create_tooltip(content_checkbox, "Cerca le parole chiave anche all'interno dei file di testo")

        # Aggiungi un'opzione per limitare la profondità di ricerca
        depth_frame = ttk.Frame(options_frame)
        depth_frame.pack(side=RIGHT, padx=5)
        
        ttk.Label(depth_frame, text="Profondità max:").pack(side=LEFT)
        
        self.depth_spinbox = ttk.Spinbox(depth_frame, from_=0, to=10, width=3)
        self.depth_spinbox.pack(side=LEFT)
        self.depth_spinbox.set("0")  # 0 significa illimitato
        self.create_tooltip(self.depth_spinbox, "Limita la profondità di ricerca nelle sottocartelle.\n0 = Illimitato.\n1 = Cerca solo nella cartella selezionata e nelle sue sottocartelle immediate.")
        
        # Aggiungi pulsante per filtri avanzati
        ttk.Button(options_frame, text="Filtri avanzati", 
                  command=self.show_advanced_filters_dialog).pack(side=RIGHT, padx=5)
        
        # Frame per le opzioni di performance e timeout
        perf_frame = ttk.LabelFrame(main_frame, text="Opzioni di Performance", padding="5")
        perf_frame.pack(fill=X, pady=5)
        
        # Opzione timeout
        timeout_frame = ttk.Frame(perf_frame)
        timeout_frame.pack(side=LEFT, padx=10, fill=X, expand=True)
        
        timeout_cb = ttk.Checkbutton(timeout_frame, text="Timeout ricerca", variable=self.timeout_enabled)
        timeout_cb.pack(side=LEFT)
        
        ttk.Label(timeout_frame, text="Secondi:").pack(side=LEFT, padx=(10, 5))
        timeout_spinbox = ttk.Spinbox(timeout_frame, from_=10, to=600, width=4, 
                                     textvariable=self.timeout_seconds)
        timeout_spinbox.pack(side=LEFT)
        self.create_tooltip(timeout_cb, "Interrompe automaticamente la ricerca dopo il tempo specificato")
        
        # Opzione thread paralleli
        threads_frame = ttk.Frame(perf_frame)
        threads_frame.pack(side=LEFT, padx=10)
        
        ttk.Label(threads_frame, text="Thread:").pack(side=LEFT)
        threads_spinbox = ttk.Spinbox(threads_frame, from_=1, to=16, width=2, 
                                     textvariable=self.worker_threads)
        threads_spinbox.pack(side=LEFT, padx=5)
        self.create_tooltip(threads_frame, "Numero di thread paralleli per la ricerca nei contenuti")
        
        # Opzione dimensione massima file
        filesize_frame = ttk.Frame(perf_frame)
        filesize_frame.pack(side=LEFT, padx=10)
        
        ttk.Label(filesize_frame, text="Max file MB:").pack(side=LEFT)
        max_size_spinbox = ttk.Spinbox(filesize_frame, from_=1, to=1000, width=4,
                                     textvariable=self.max_file_size_mb)
        max_size_spinbox.pack(side=LEFT, padx=5)
        self.create_tooltip(filesize_frame, "Dimensione massima dei file da analizzare (in MB)")
        
        # Opzione numero massimo di risultati
        max_results_frame = ttk.Frame(perf_frame)
        max_results_frame.pack(side=LEFT, padx=10)
        
        ttk.Label(max_results_frame, text="Max risultati:").pack(side=LEFT)
        max_results_spinbox = ttk.Spinbox(max_results_frame, from_=100, to=100000, width=6,
                                         textvariable=self.max_results)
        max_results_spinbox.pack(side=LEFT, padx=5)
        self.create_tooltip(max_results_frame, "Numero massimo di risultati da mostrare")
        
        # Opzione indicizzazione
        indexing_frame = ttk.Frame(perf_frame)
        indexing_frame.pack(side=LEFT, padx=10)
        
        indexing_cb = ttk.Checkbutton(indexing_frame, text="Indicizzazione", 
                                     variable=self.use_indexing)
        indexing_cb.pack(side=LEFT)
        self.create_tooltip(indexing_cb, "Memorizza i risultati per velocizzare ricerche future")
        
        # Frame per i pulsanti di ricerca
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(pady=5)
        
        # Pulsante di ricerca
        self.search_button = ttk.Button(button_frame, text="Cerca", 
                                      command=self.start_search, 
                                      style="primary.TButton")
        self.search_button.pack(side=LEFT, padx=5)
        
        # Pulsante per interrompere la ricerca
        self.stop_button = ttk.Button(button_frame, 
                                     text="Interrompi ricerca",
                                     command=self.stop_search_process,
                                     style="danger.TButton",
                                     state="disabled")
        self.stop_button.pack(side=LEFT, padx=5)
        
        # Pulsante per pulire i campi di ricerca
        ttk.Button(button_frame, 
                  text="Pulisci campi", 
                  command=lambda: [self.search_path.set(""), self.keywords.set("")],
                  style="secondary.Outline.TButton").pack(side=LEFT, padx=5)
        
# Frame separatore per migliorare la visualizzazione
        separator = ttk.Separator(main_frame, orient='horizontal')
        separator.pack(fill=X, pady=10)
        
        # Nuovo frame per le etichette di tempo con stile migliorato
        time_frame = ttk.LabelFrame(main_frame, text="Informazioni temporali", padding="5")
        time_frame.pack(fill=X, pady=(0, 10))
        
        # Container interno per le etichette
        time_labels_container = ttk.Frame(time_frame)
        time_labels_container.pack(expand=True)
        
        # Frame per l'orario di avvio
        start_time_frame = ttk.Frame(time_labels_container)
        start_time_frame.pack(side=LEFT, padx=20)
        
        ttk.Label(start_time_frame, 
                text="Avvio ricerca:", 
                font=("", 9)).pack(side=LEFT)
        
        self.start_time_label = ttk.Label(start_time_frame, 
                                        text="--:--", 
                                        font=("", 9, "bold"))
        self.start_time_label.pack(side=LEFT, padx=(5, 0))
        
        # Separatore verticale tra le etichette
        ttk.Separator(time_labels_container, orient='vertical').pack(side=LEFT, fill=Y, padx=15)
        
        # Frame per l'orario di fine
        end_time_frame = ttk.Frame(time_labels_container)
        end_time_frame.pack(side=LEFT, padx=20)
        
        ttk.Label(end_time_frame, 
                text="Fine ricerca:", 
                font=("", 9)).pack(side=LEFT)
        
        self.end_time_label = ttk.Label(end_time_frame, 
                                    text="--:--", 
                                    font=("", 9, "bold"))
        self.end_time_label.pack(side=LEFT, padx=(5, 0))
               
        # Area risultati
        results_frame = ttk.LabelFrame(main_frame, text="Risultati", padding="5")
        results_frame.pack(fill=BOTH, expand=YES, pady=5)

        # Frame per i pulsanti di azione
        action_buttons_frame = ttk.Frame(results_frame)
        action_buttons_frame.pack(fill=X, pady=(0, 5))
        
        # Pulsanti per la selezione
        ttk.Button(action_buttons_frame, text="Seleziona tutto", 
                  command=self.select_all).pack(side=LEFT, padx=2)
        ttk.Button(action_buttons_frame, text="Deseleziona tutto", 
                  command=self.deselect_all).pack(side=LEFT, padx=2)
        ttk.Button(action_buttons_frame, text="Inverti selezione", 
                  command=self.invert_selection).pack(side=LEFT, padx=2)
        
        # Scrollbar per la lista risultati
        scrollbar = ttk.Scrollbar(results_frame)
        scrollbar.pack(side=RIGHT, fill=Y)
        
        # Configura la Treeview
        self.results_list = ttk.Treeview(results_frame, selectmode="extended",
                            columns=("type", "author", "size", "modified", "created", "path"),
                            show="headings")

        # Imposta le colonne con larghezze appropriate e centraggio
        self.results_list.column("type", width=150, anchor="center")
        self.results_list.column("author", width=100, anchor="w")
        self.results_list.column("size", width=100, anchor="center")
        self.results_list.column("modified", width=140, anchor="center")
        self.results_list.column("created", width=140, anchor="center")
        self.results_list.column("path", width=400, anchor="w")
        
        # Imposta le intestazioni
        self.results_list.heading("type", text="Tipo File")
        self.results_list.heading("author", text="Nome File")
        self.results_list.heading("size", text="Dimensione")
        self.results_list.heading("modified", text="Modificato")
        self.results_list.heading("created", text="Creato")
        self.results_list.heading("path", text="Percorso")

        # Impostazione delle larghezze colonne
        self.results_list.column("type", width=80)
        self.results_list.column("author", width=250)
        self.results_list.column("size", width=80)
        self.results_list.column("modified", width=80)
        self.results_list.column("created", width=80)
        self.results_list.column("path", width=500)
        
        self.results_list.pack(fill=BOTH, expand=YES)
        
        scrollbar.config(command=self.results_list.yview)
        self.results_list.config(yscrollcommand=scrollbar.set)
        
        # Frame per i pulsanti di azione principali
        main_buttons_frame = ttk.Frame(main_frame)
        main_buttons_frame.pack(fill=X, pady=5)
        
        # Pulsanti copia e comprimi
        self.copy_button = ttk.Button(main_buttons_frame, text="Copia selezionati",
                                    command=self.copy_selected,
                                    style="TButton")
        self.copy_button.pack(side=LEFT, padx=5)
        
        self.compress_button = ttk.Button(main_buttons_frame, text="Comprimi selezionati",
                                        command=self.compress_selected,
                                        style="TButton")
        self.compress_button.pack(side=LEFT, padx=5)
        
        # Frame della barra di stato (in basso)
        status_frame = ttk.Frame(self.root)
        status_frame.pack(fill=X, side=BOTTOM, pady=2)
        
        # Frame info (sinistra)
        info_frame = ttk.Frame(status_frame)
        info_frame.pack(side=LEFT, fill=X, expand=YES, padx=5)
        
        # Status label (in basso a sinistra)
        self.status_label = ttk.Label(info_frame, text="In attesa...", justify=LEFT)
        self.status_label.pack(side=LEFT, padx=5)
        
        # DateTime e User label (in basso a destra)
        ttk.Label(status_frame, textvariable=self.datetime_var).pack(side=RIGHT, padx=5)
        
        # Progress bar (sopra la barra di stato)
        progress_frame = ttk.Frame(self.root)
        progress_frame.pack(fill=X, side=BOTTOM, pady=(0, 2))
        
        self.progress_bar = ttk.Progressbar(progress_frame, mode='determinate', length=200)
        self.progress_bar.pack(fill=X, padx=5)
        
        # Aggiungi tooltip ai pulsanti principali
        self.create_tooltip(self.search_button, "Avvia la ricerca con i criteri specificati")
        self.create_tooltip(self.copy_button, "Copia i file selezionati nella directory specificata")
        self.create_tooltip(self.compress_button, "Comprimi i file selezionati in un archivio ZIP")
    
    # Avviso sulla spunta della ricerca dei contenuti
    def warn_content_search(self):
        """Mostra un avviso se l'utente attiva la ricerca nei contenuti"""
        if self.search_content.get():  # Se la checkbox è stata appena attivata
            messagebox.showwarning(
                "Attenzione", 
                "Attivando questa opzione rallenterà la ricerca e l'attesa sarà maggiore.",
                parent=self.root
            )

    def create_tooltip(self, widget, text, delay=500, fade=True):
        """Crea tooltip con ritardo, effetti di dissolvenza e larghezza automatica"""
        
        tooltip_timer = None
        fade_timer = None
        
        def show_tooltip():
            x = widget.winfo_rootx() + 25
            y = widget.winfo_rooty() + 25
            
            tooltip = ttk.Toplevel(widget)
            tooltip.wm_overrideredirect(True)
            tooltip.attributes("-alpha", 0.0)  # Inizia invisibile
            tooltip.attributes("-topmost", True)  # Mantiene sopra altre finestre
            
            # Crea un frame con bordo e padding
            frame = ttk.Frame(tooltip, borderwidth=1, relief="solid", padding=10)
            frame.pack(fill="both", expand=True)
            
            # Calcolo della larghezza del testo
            font = ("Segoe UI", 9)  # Puoi modificare questo per usare un altro font
            
            # Calcola la lunghezza approssimativa del testo
            import tkinter as tk
            temp_label = tk.Label(font=font)
            
            # Determina se il testo necessita di essere diviso in più righe
            lines = text.split("\n")
            max_line_width = 0
            
            for line in lines:
                temp_label.configure(text=line)
                line_width = temp_label.winfo_reqwidth()
                max_line_width = max(max_line_width, line_width)
            
            # Limita la larghezza massima a 500 pixel
            max_width = min(max_line_width, 500)
            
            # Se il testo è più corto della larghezza massima, non imposta wraplength
            # altrimenti imposta wraplength per dividere il testo in righe
            if max_line_width > 500:
                wraplength = 500
            else:
                wraplength = max_line_width
                
            # Crea l'etichetta con il testo
            label = ttk.Label(frame, text=text, justify="left", 
                            wraplength=wraplength, font=font)
            label.pack(fill="both", expand=True)
            
            # Distruggi il label temporaneo
            temp_label.destroy()
            
            # Aggiorna immediatamente per calcolare le dimensioni
            tooltip.update_idletasks()
            
            # Posiziona il tooltip in modo che non vada fuori dallo schermo
            tooltip_width = tooltip.winfo_reqwidth()
            tooltip_height = tooltip.winfo_reqheight()
            
            screen_width = tooltip.winfo_screenwidth()
            screen_height = tooltip.winfo_screenheight()
            
            # Aggiusta la posizione se il tooltip esce dallo schermo
            if x + tooltip_width > screen_width:
                x = screen_width - tooltip_width - 10
            
            if y + tooltip_height > screen_height:
                y = screen_height - tooltip_height - 10
                
            # Imposta la posizione finale
            tooltip.wm_geometry(f"+{x}+{y}")
            
            widget._tooltip = tooltip
            
            if fade:
                # Effetto dissolvenza in entrata
                def fade_in(alpha=0.0):
                    if not hasattr(widget, "_tooltip"):
                        return
                    
                    tooltip.attributes("-alpha", alpha)
                    if alpha < 1.0:
                        nonlocal fade_timer
                        fade_timer = widget.after(20, lambda: fade_in(alpha + 0.1))
                
                fade_in()
        
        def enter(event):
            nonlocal tooltip_timer
            # Avvia il timer per mostrare il tooltip dopo un certo ritardo
            tooltip_timer = widget.after(delay, show_tooltip)
        
        def leave(event):
            nonlocal tooltip_timer, fade_timer
            
            # Cancella il timer se esiste
            if tooltip_timer:
                widget.after_cancel(tooltip_timer)
                tooltip_timer = None
            
            # Cancella il timer di dissolvenza se esiste
            if fade_timer:
                widget.after_cancel(fade_timer)
                fade_timer = None
            
            # Rimuovi il tooltip se esiste
            if hasattr(widget, "_tooltip"):
                if fade:
                    # Effetto dissolvenza in uscita
                    def fade_out(alpha=1.0):
                        if alpha <= 0 or not hasattr(widget, "_tooltip"):
                            if hasattr(widget, "_tooltip"):
                                widget._tooltip.destroy()
                                del widget._tooltip
                        else:
                            widget._tooltip.attributes("-alpha", alpha)
                            nonlocal fade_timer
                            fade_timer = widget.after(20, lambda: fade_out(alpha - 0.1))
                    
                    fade_out()
                else:
                    widget._tooltip.destroy()
                    del widget._tooltip
        
        # Gestisce anche il caso in cui il widget venga distrutto
        def on_destroy(event):
            nonlocal tooltip_timer, fade_timer
            if tooltip_timer:
                widget.after_cancel(tooltip_timer)
            if fade_timer and hasattr(widget, "_tooltip"):
                widget.after_cancel(fade_timer)
                widget._tooltip.destroy()
        
        widget.bind("<Enter>", enter)
        widget.bind("<Leave>", leave)
        widget.bind("<Destroy>", on_destroy)

    def select_all(self):
        self.results_list.selection_set(self.results_list.get_children())
        
    def deselect_all(self):
        self.results_list.selection_remove(self.results_list.get_children())
        
    def invert_selection(self):
        all_items = self.results_list.get_children()
        selected_items = self.results_list.selection()
        self.results_list.selection_remove(selected_items)
        to_select = set(all_items) - set(selected_items)
        for item in to_select:
            self.results_list.selection_add(item)

# Funzione principale per eseguire l'applicazione
def main():
    import sys
    root = ttk.Window(themename="darkly")
    app = FileSearchApp(root)
    
    # Verifica se ci sono argomenti da linea di comando
    if len(sys.argv) > 1:
        # Se c'è un percorso fornito come argomento, lo imposta come percorso di ricerca
        app.search_path.set(sys.argv[1])
    
    root.mainloop()

if __name__ == "__main__":
    main()
