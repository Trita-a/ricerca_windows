import os
import shutil
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from tkinter import filedialog, messagebox, BooleanVar, StringVar
import threading
import queue
from datetime import datetime
import getpass
import zipfile
from ttkbootstrap.dialogs import Querybox
import traceback

# Dizionario per tracciare il supporto alle librerie
file_format_support = {
    "docx": False,
    "pdf": False,
    "pptx": False,
    "excel": False,
    "odt": False,
    "rtf": False
}

# Elenco di librerie da installare se mancanti
missing_libraries = []

# Importazione di librerie opzionali con gestione degli errori
try:
    import docx
    file_format_support["docx"] = True
    print("Supporto Word (.docx) attivato")
except ImportError:
    missing_libraries.append("python-docx")
    print("Supporto Word (.docx) non disponibile")

try:
    import PyPDF2
    file_format_support["pdf"] = True
    print("Supporto PDF attivato")
except ImportError:
    missing_libraries.append("PyPDF2")
    print("Supporto PDF non disponibile")

try:
    import pptx
    file_format_support["pptx"] = True
    print("Supporto PowerPoint attivato")
except ImportError:
    missing_libraries.append("python-pptx")
    print("Supporto PowerPoint non disponibile")

try:
    import openpyxl
    file_format_support["excel"] = True
    print("Supporto Excel attivato")
except ImportError:
    missing_libraries.append("openpyxl")
    print("Supporto Excel non disponibile")

try:
    from striprtf.striprtf import rtf_to_text
    file_format_support["rtf"] = True
    print("Supporto RTF attivato")
except ImportError:
    missing_libraries.append("striprtf")
    print("Supporto RTF non disponibile")

try:
    import odfdo
    file_format_support["odt"] = True
    print("Supporto ODT attivato (libreria odfdo)")
except ImportError:
    try:
        from odf import opendocument, text, teletype
        file_format_support["odt"] = True
        print("Supporto ODT attivato (libreria odf)")
    except ImportError:
        missing_libraries.append("odfdo")
        print("Supporto ODT non disponibile")

class FileSearchApp:
    def __init__(self, root):
        self.root = root
        self.root.title("File Search Tool.. Nucleo Perugia")
        self.root.geometry("1300x850")
        
        # Inizializza le variabili per data/ora e utente
        self.datetime_var = StringVar()
        self.user_var = StringVar(value=getpass.getuser())
        
        # Avvia l'aggiornamento automatico della data/ora
        self.update_current_datetime()

        # Variabili
        self.search_content = BooleanVar(value=False)
        self.search_path = StringVar()
        self.keywords = StringVar()
        self.search_results = []
        self.search_files = BooleanVar(value=True)
        self.search_folders = BooleanVar(value=True)
        self.ignore_hidden = BooleanVar(value=True)  # Aggiungi questa riga
        self.is_searching = False
        self.progress_queue = queue.Queue()
        
        # Variabili aggiuntive per i miglioramenti
        self.stop_search = False
        self.max_depth = 0  # 0 = illimitato
        self.last_search_params = {}
        self.search_history = []
        self.advanced_filters = {
            "size_min": 0,
            "size_max": 0,
            "date_min": None,
            "date_max": None,
            "extensions": []
        }
        
        # Info utente e datetime
        self.current_user = getpass.getuser()
        self.datetime_var = StringVar()
        self.update_datetime()
        self.create_widgets()

        # Verifica le librerie e mostra notifica se necessario
        self.check_and_notify_missing_libraries()
        self.debug_mode = True

    def log_debug(self, message):
        """Funzione per logging, stampa solo quando debug_mode è True"""
        if self.debug_mode:
            print(f"[DEBUG] {message}")

    def check_and_notify_missing_libraries(self):
        """Verifica e notifica l'utente di eventuali librerie mancanti"""
        missing = []
        
        if not file_format_support["docx"]:
            missing.append("python-docx (per file Word)")
        if not file_format_support["pdf"]: 
            missing.append("PyPDF2 (per file PDF)")
        if not file_format_support["pptx"]:
            missing.append("python-pptx (per file PowerPoint)")
        if not file_format_support["excel"]:
            missing.append("openpyxl (per file Excel)")
        if not file_format_support["rtf"]:
            missing.append("striprtf (per file RTF)")
        if not file_format_support["odt"]:
            missing.append("odfdo (per file OpenDocument)")
        
        if missing:
            message = "Alcune funzionalità di ricerca nei contenuti sono disabilitate.\n\n"
            message += "Per abilitare il supporto completo ai vari formati di file, installa le seguenti librerie:\n\n"
            
            for lib in missing:
                message += f"- {lib}\n"
            
            message += "\nPuoi installarle con il comando:\n"
            message += "pip install " + " ".join([lib.split(" ")[0] for lib in missing])
            
            # Mostra la notifica dopo un breve ritardo per permettere all'UI di caricarsi
            self.root.after(1000, lambda: messagebox.showinfo("Librerie opzionali mancanti", message))

    def update_datetime(self):
        current_time = datetime.now().strftime('%d-%m-%Y %H:%M:%S')
        self.datetime_var.set(f"Data: {current_time} | Utente: {self.current_user}")
        self.root.after(1000, self.update_datetime)

    def browse_directory(self):
        directory = filedialog.askdirectory()
        if directory:
            self.search_path.set(directory)
            
    def start_search(self):
        # Pulisci risultati precedenti
        for item in self.results_list.get_children():
            self.results_list.delete(item)
        
        if not self.search_path.get() or not self.keywords.get():
            messagebox.showerror("Errore", "Inserisci directory e parole chiave")
            return
        
        # Reset per la nuova ricerca
        self.stop_search = False
        self.stop_button["state"] = "normal"
        
         # Aggiorna l'orario di avvio e resetta l'orario di fine
        current_time = datetime.now().strftime('%H:%M')
        self.start_time_label.config(text=current_time)
        self.end_time_label.config(text="--:--")

        # Salva i parametri di ricerca
        self.last_search_params = {
            "path": self.search_path.get(),
            "keywords": self.keywords.get(),
            "search_files": self.search_files.get(),
            "search_folders": self.search_folders.get(),
            "search_content": self.search_content.get()  # Aggiungi questa riga
        }
        
        # Aggiungi alla cronologia di ricerca se non già presente
        if self.keywords.get() and self.keywords.get() not in [h["keywords"] for h in self.search_history]:
            self.search_history.append(self.last_search_params.copy())
            if len(self.search_history) > 10:  # Mantieni solo le ultime 10 ricerche
                self.search_history.pop(0)
        
        self.is_searching = True
        self.search_button["state"] = "disabled"
        self.progress_bar["value"] = 0
        self.status_label["text"] = "Ricerca in corso..."
        
        # Aggiorna il valore della profondità massima
        try:
            self.max_depth = int(self.depth_spinbox.get())
        except ValueError:
            self.max_depth = 0  # Valore predefinito se non valido
        
        # Ottieni le parole chiave di ricerca
        search_terms = [term.strip() for term in self.keywords.get().split(',') if term.strip()]
            
        # Avvia la ricerca in un thread separato
        self.search_results = []  # Resetta i risultati
        search_thread = threading.Thread(target=self._search_thread, 
                                        args=(self.search_path.get(), search_terms, self.search_content.get()))
        search_thread.daemon = True
        search_thread.start()
        
        # Avvia l'aggiornamento della progress bar
        self.update_progress()

    def update_progress(self):
        if self.is_searching:
            try:
                while True:
                    progress_type, value = self.progress_queue.get_nowait()
                    if progress_type == "progress":
                        self.progress_bar["value"] = value
                    elif progress_type == "status":
                        self.status_label["text"] = value
                    elif progress_type == "complete":
                        self.is_searching = False
                        self.search_button["state"] = "normal"
                        self.stop_button["state"] = "disabled"
                        
                        # Aggiorna la lista dei risultati - QUESTA RIGA MANCAVA
                        self.update_results_list()
                        
                        if len(self.search_results) == 0:
                            self.status_label["text"] = "Nessun file trovato per la ricerca effettuata"
                            # Opzionale: mostra un messaggio popup
                            self.root.after(100, lambda: messagebox.showinfo("Ricerca completata", "Nessun file trovato per la ricerca effettuata"))
                        else:
                            self.status_label["text"] = f"Ricerca completata! Trovati {len(self.search_results)} risultati."
                        
                        self.progress_bar["value"] = 100
                        return
                    elif progress_type == "error":
                        self.is_searching = False
                        self.search_button["state"] = "normal"
                        self.stop_button["state"] = "disabled"
                        messagebox.showerror("Errore", value)
                        return
            except queue.Empty:
                pass
                    
            self.root.after(100, self.update_progress)
            
    def stop_search_process(self):
        """Ferma il processo di ricerca in corso"""
        self.stop_search = True
        self.status_label["text"] = "Interrompendo la ricerca..."
        # Aggiorna l'orario di fine quando la ricerca viene interrotta
        current_time = datetime.now().strftime('%H:%M')
        self.end_time_label.config(text=current_time)

    def show_advanced_filters_dialog(self):
        """Mostra la finestra di dialogo per i filtri di ricerca avanzati"""
        dialog = ttk.Toplevel(self.root)
        dialog.title("Filtri avanzati")
        dialog.geometry("530x350")
        dialog.transient(self.root)
        dialog.grab_set()
        
        # Filtri dimensione
        size_frame = ttk.LabelFrame(dialog, text="Dimensione file")
        size_frame.pack(fill=X, padx=10, pady=5)
        
        ttk.Label(size_frame, text="Min (KB):").grid(row=0, column=0, padx=5, pady=5)
        min_size = ttk.Entry(size_frame, width=10)
        min_size.grid(row=0, column=1, padx=5, pady=5)
        min_size.insert(0, str(self.advanced_filters["size_min"] // 1024))
        
        ttk.Label(size_frame, text="Max (KB):").grid(row=0, column=2, padx=5, pady=5)
        max_size = ttk.Entry(size_frame, width=10)
        max_size.grid(row=0, column=3, padx=5, pady=5)
        max_size.insert(0, str(self.advanced_filters["size_max"] // 1024 if self.advanced_filters["size_max"] else 0))
        
        # Filtri data - FORMAT DD-MM-YYYY
        date_frame = ttk.LabelFrame(dialog, text="Data modifica (DD-MM-YYYY)")
        date_frame.pack(fill=X, padx=10, pady=5)
        
        ttk.Label(date_frame, text="Da:").grid(row=0, column=0, padx=5, pady=5)
        min_date = ttk.DateEntry(date_frame, dateformat="%d-%m-%Y")
        min_date.grid(row=0, column=1, padx=5, pady=5)
        
        ttk.Label(date_frame, text="A:").grid(row=0, column=2, padx=5, pady=5)
        max_date = ttk.DateEntry(date_frame, dateformat="%d-%m-%Y")
        max_date.grid(row=0, column=3, padx=5, pady=5)
        
        # Prepopola le date se disponibili
        if self.advanced_filters["date_min"]:
            min_date.entry.delete(0, "end")
            min_date.entry.insert(0, self.advanced_filters["date_min"])
                
        if self.advanced_filters["date_max"]:
            max_date.entry.delete(0, "end")
            max_date.entry.insert(0, self.advanced_filters["date_max"])
        
        # Filtri estensione
        ext_frame = ttk.LabelFrame(dialog, text="Estensioni file (separate da virgola)")
        ext_frame.pack(fill=X, padx=10, pady=5)
        example_label = ttk.Label(ext_frame, text="Inserisci una o più estensioni da ricercare. Esempio: .pdf, .dot", 
                       font=("", 8), foreground="gray")
        example_label.pack(anchor="w", padx=5)
        
        extensions = ttk.Entry(ext_frame)
        extensions.pack(fill=X, padx=5, pady=5)
        if self.advanced_filters["extensions"]:
            extensions.insert(0, ", ".join(self.advanced_filters["extensions"]))
        
        # Aggiungiamo un frame di debug per vedere i filtri correnti
        debug_frame = ttk.LabelFrame(dialog, text="Debug - Stato filtri correnti")
        debug_frame.pack(fill=X, padx=10, pady=5)
        
        debug_text = ttk.Text(debug_frame, height=3, width=50)
        debug_text.pack(fill=X, padx=5, pady=5)
        debug_text.insert("1.0", f"Data min: {self.advanced_filters['date_min']}\n")
        debug_text.insert("2.0", f"Data max: {self.advanced_filters['date_max']}\n")
        debug_text.insert("3.0", f"Extensions: {self.advanced_filters['extensions']}")
        debug_text.config(state="disabled")
        
        # Pulsante Salva
        def save_filters():
            try:
                # Analizza i filtri di dimensione
                min_kb = int(min_size.get() or 0)
                max_kb = int(max_size.get() or 0)
                self.advanced_filters["size_min"] = min_kb * 1024
                self.advanced_filters["size_max"] = max_kb * 1024
                
                # CORREZIONE: Ottieni le date nel formato DD-MM-YYYY
                min_date_value = min_date.entry.get().strip()
                max_date_value = max_date.entry.get().strip()
                
                print(f"DEBUG - Date inserite: min={min_date_value}, max={max_date_value}")
                
                # Validazione date
                if min_date_value:
                    try:
                        # Verifica formato corretto
                        datetime.strptime(min_date_value, "%d-%m-%Y")
                    except ValueError:
                        messagebox.showerror("Errore", "Formato data minima non valido. Usa DD-MM-YYYY")
                        return
                
                if max_date_value:
                    try:
                        # Verifica formato corretto
                        datetime.strptime(max_date_value, "%d-%m-%Y")
                    except ValueError:
                        messagebox.showerror("Errore", "Formato data massima non valido. Usa DD-MM-YYYY")
                        return
                
                # Verifica che la data minima non sia successiva alla data massima
                if min_date_value and max_date_value:
                    min_date_obj = datetime.strptime(min_date_value, "%d-%m-%Y")
                    max_date_obj = datetime.strptime(max_date_value, "%d-%m-%Y")
                    
                    if min_date_obj > max_date_obj:
                        messagebox.showerror("Errore", 
                                            "La data di inizio non può essere successiva alla data di fine")
                        return
                
                # Salva le date validate
                self.advanced_filters["date_min"] = min_date_value
                self.advanced_filters["date_max"] = max_date_value
                
                # Analizza le estensioni
                exts = [e.strip() for e in extensions.get().split(",") if e.strip()]
                self.advanced_filters["extensions"] = [f".{e.lstrip('.')}" for e in exts]
                
                print(f"Filtri salvati: {self.advanced_filters}")  # Debug info
                dialog.destroy()
                
            except ValueError:
                messagebox.showerror("Errore", "Inserisci valori numerici validi per le dimensioni")
        
        ttk.Button(dialog, text="Salva", command=save_filters).pack(pady=10)
        ttk.Button(dialog, text="Annulla", command=dialog.destroy).pack(pady=5)

        dialog.update_idletasks()  # Aggiorna la finestra per ottenere le dimensioni corrette
        width = dialog.winfo_width()
        height = dialog.winfo_height()
        x = (dialog.winfo_screenwidth() // 2) - (width // 2)
        y = (dialog.winfo_screenheight() // 2) - (height // 2)
        dialog.geometry(f"{width}x{height}+{x}+{y}")
        
        # Imposta una dimensione minima per la finestra
        dialog.minsize(500, 400)

    def update_current_datetime(self):
        """Aggiorna le informazioni di data/ora correnti nel formato UTC"""
        current_time = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')
        self.datetime_var.set(f"Current Date and Time (UTC - YYYY-MM-DD HH:MM:SS formatted): {current_time}\nCurrent User's Login: {self.user_var.get()}")
        
        # Aggiorna il label se esiste
        if hasattr(self, 'datetime_label'):
            self.datetime_label.configure(text=self.datetime_var.get())
        
        # Programma il prossimo aggiornamento tra 1 secondo
        self.root.after(1000, self.update_current_datetime)

    def create_widgets(self):
        # Frame principale che conterrà tutto tranne la barra di stato
        main_container = ttk.Frame(self.root)
        main_container.pack(fill=BOTH, expand=YES)
        
        # Frame principale per il contenuto
        main_frame = ttk.Frame(main_container, padding="10")
        main_frame.pack(fill=BOTH, expand=YES)
        
        # Aggiungi selezione tema
        theme_frame = ttk.Frame(main_frame)
        theme_frame.pack(fill=X, pady=5)
        
        ttk.Label(theme_frame, text="Tema:").pack(side=LEFT, padx=5)
        themes = ttk.Style().theme_names()
        theme_combobox = ttk.Combobox(theme_frame, values=themes, width=15)
        theme_combobox.pack(side=LEFT, padx=5)
        theme_combobox.current(themes.index("darkly"))
        theme_combobox.bind("<<ComboboxSelected>>", lambda e: ttk.Style().theme_use(theme_combobox.get()))
        
        # Sezione selezione directory
        path_frame = ttk.LabelFrame(main_frame, text="Directory di ricerca", padding="5")
        path_frame.pack(fill=X, pady=5)
       
        self.path_entry = ttk.Entry(path_frame, textvariable=self.search_path)
        example_label = ttk.Label(path_frame, text="Seleziona la directory per effettuare la ricerca dei file", 
                       font=("", 8), foreground="gray")
        example_label.pack(anchor="w", padx=5)
        self.path_entry.pack(side=LEFT, fill=X, expand=YES, padx=5)
        

        ttk.Button(path_frame, text="Sfoglia", command=self.browse_directory).pack(side=LEFT, padx=5)
        # Sezione keywords
        keyword_frame = ttk.LabelFrame(main_frame, text="Parole chiave", padding="5")
        keyword_frame.pack(fill=X, pady=5)

         # Aggiungi il tooltip sulla casella delle parole chiave
        example_label = ttk.Label(keyword_frame, text="Per la ricerca di più parole usa la virgola. Esempio: documento, fattura, contratto", 
                       font=("", 8), foreground="gray")
        example_label.pack(anchor="w", padx=5)

        # Crea l'entry delle parole chiave e salvala come attributo dell'istanza
        self.keyword_entry = ttk.Entry(keyword_frame, textvariable=self.keywords)
        self.keyword_entry.pack(fill=X, padx=5)
           
        # Opzioni di ricerca
        options_frame = ttk.LabelFrame(main_frame, text="Opzioni di ricerca", padding="5")
        options_frame.pack(fill=X, pady=5)
        example_label = ttk.Label(options_frame, text="Seleziona una o più opzioni per la ricerca", 
                       font=("", 8), foreground="gray")
        example_label.pack(anchor="w", padx=5)
        ttk.Checkbutton(options_frame, text="Cerca file", variable=self.search_files).pack(side=LEFT, padx=5)
        ttk.Checkbutton(options_frame, text="Cerca cartelle", variable=self.search_folders).pack(side=LEFT, padx=5)
        
        # Checkbox "Cerca nei contenuti" 
        content_checkbox = ttk.Checkbutton(options_frame, text="Cerca nei contenuti", 
                                  variable=self.search_content, 
                                  command=self.warn_content_search)
        content_checkbox.pack(side=LEFT, padx=5)
        self.create_tooltip(content_checkbox, "Cerca le parole chiave anche all'interno dei file di testo")

        # Aggiungi un'opzione per limitare la profondità di ricerca
        depth_frame = ttk.Frame(options_frame)
        depth_frame.pack(side=RIGHT, padx=5)
        
        ttk.Label(depth_frame, text="Profondità max:").pack(side=LEFT)
        
        self.depth_spinbox = ttk.Spinbox(depth_frame, from_=0, to=10, width=3)
        self.depth_spinbox.pack(side=LEFT)
        self.depth_spinbox.set("0")  # 0 significa illimitato
        self.create_tooltip(self.depth_spinbox, "Limita la profondità di ricerca nelle sottocartelle.\n0 = Illimitato.\n1 = Cerca solo nella cartella selezionata e nelle sue sottocartelle immediate.\n10 = Cerca fino a 10 livelli di sottocartelle.")
        
        # Aggiungi pulsante per filtri avanzati
        ttk.Button(options_frame, text="Filtri avanzati", 
                  command=self.show_advanced_filters_dialog).pack(side=RIGHT, padx=5)
        
        # Frame per i pulsanti di ricerca
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(pady=5)
        
        # Pulsante di ricerca
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(pady=5)
        
        self.search_button = ttk.Button(button_frame, text="Cerca", 
                                      command=self.start_search, 
                                      style="primary.TButton")
        self.search_button.pack(side=LEFT, padx=5)
        
        # Pulsante per interrompere la ricerca
        self.stop_button = ttk.Button(button_frame, 
                                     text="Interrompi ricerca",
                                     command=self.stop_search_process,
                                     style="danger.TButton",
                                     state="disabled")
        self.stop_button.pack(side=LEFT, padx=5)
        
        # Pulsante per pulire i campi di ricerca
        ttk.Button(button_frame, 
                  text="Pulisci campi", 
                  command=lambda: [self.search_path.set(""), self.keywords.set("")],
                  style="secondary.Outline.TButton").pack(side=LEFT, padx=5)
        
        # Frame separatore per migliorare la visualizzazione
        separator = ttk.Separator(main_frame, orient='horizontal')
        separator.pack(fill=X, pady=10)
        
        # Nuovo frame per le etichette di tempo con stile migliorato
        time_frame = ttk.LabelFrame(main_frame, text="Informazioni temporali", padding="5")
        time_frame.pack(fill=X, pady=(0, 10))
        
        # Container interno per le etichette
        time_labels_container = ttk.Frame(time_frame)
        time_labels_container.pack(expand=True)
        
        # Frame per l'orario di avvio
        start_time_frame = ttk.Frame(time_labels_container)
        start_time_frame.pack(side=LEFT, padx=20)
        
        ttk.Label(start_time_frame, 
                text="Avvio ricerca:", 
                font=("", 9)).pack(side=LEFT)
        
        self.start_time_label = ttk.Label(start_time_frame, 
                                        text="--:--", 
                                        font=("", 9, "bold"))
        self.start_time_label.pack(side=LEFT, padx=(5, 0))
        
        # Separatore verticale tra le etichette
        ttk.Separator(time_labels_container, orient='vertical').pack(side=LEFT, fill=Y, padx=15)
        
        # Frame per l'orario di fine
        end_time_frame = ttk.Frame(time_labels_container)
        end_time_frame.pack(side=LEFT, padx=20)
        
        ttk.Label(end_time_frame, 
                text="Fine ricerca:", 
                font=("", 9)).pack(side=LEFT)
        
        self.end_time_label = ttk.Label(end_time_frame, 
                                    text="--:--", 
                                    font=("", 9, "bold"))
        self.end_time_label.pack(side=LEFT, padx=(5, 0))
               
        # Area risultati
        results_frame = ttk.LabelFrame(main_frame, text="Risultati", padding="5")
        results_frame.pack(fill=BOTH, expand=YES, pady=5)

        # Frame per i pulsanti di azione
        action_buttons_frame = ttk.Frame(results_frame)
        action_buttons_frame.pack(fill=X, pady=(0, 5))
        
        # Pulsanti per la selezione
        ttk.Button(action_buttons_frame, text="Seleziona tutto", 
                  command=self.select_all).pack(side=LEFT, padx=2)
        ttk.Button(action_buttons_frame, text="Deseleziona tutto", 
                  command=self.deselect_all).pack(side=LEFT, padx=2)
        ttk.Button(action_buttons_frame, text="Inverti selezione", 
                  command=self.invert_selection).pack(side=LEFT, padx=2)
        
        # Scrollbar per la lista risultati
        scrollbar = ttk.Scrollbar(results_frame)
        scrollbar.pack(side=RIGHT, fill=Y)
        
        # Configura la Treeview
        self.results_list = ttk.Treeview(results_frame, selectmode="extended",
                            columns=("type", "match", "size", "modified", "created", "path"),
                            show="headings")
        
        # Imposta le colonne con larghezze appropriate
        self.results_list.column("type", width=150, anchor="w")
        self.results_list.column("match", width=100)
        self.results_list.column("size", width=100)
        self.results_list.column("modified", width=140)
        self.results_list.column("created", width=140)
        self.results_list.column("path", width=400)
        
        # Imposta le intestazioni
        self.results_list.heading("type", text="Tipo File")
        self.results_list.heading("match", text="Trovato in")
        self.results_list.heading("size", text="Dimensione")
        self.results_list.heading("modified", text="Modificato")
        self.results_list.heading("created", text="Creato")
        self.results_list.heading("path", text="Percorso")

        # Impostazione delle larghezze colonne
        self.results_list.column("type", width=80)
        self.results_list.column("match", width=100)
        self.results_list.column("size", width=100)
        self.results_list.column("modified", width=140)
        self.results_list.column("created", width=140)
        self.results_list.column("path", width=440)
        
        self.results_list.pack(fill=BOTH, expand=YES)
        
        scrollbar.config(command=self.results_list.yview)
        self.results_list.config(yscrollcommand=scrollbar.set)
        
        # Frame per i pulsanti di azione principali
        main_buttons_frame = ttk.Frame(main_frame)
        main_buttons_frame.pack(fill=X, pady=5)
        
        # Pulsanti copia e comprimi
        self.copy_button = ttk.Button(main_buttons_frame, text="Copia selezionati",
                                    command=self.copy_selected,
                                    style="TButton")  # Changed style here
        self.copy_button.pack(side=LEFT, padx=5)
        
        self.compress_button = ttk.Button(main_buttons_frame, text="Comprimi selezionati",
                                        command=self.compress_selected,
                                        style="TButton")  # Changed style here
        self.compress_button.pack(side=LEFT, padx=5)
        
        # Frame della barra di stato (in basso)
        status_frame = ttk.Frame(self.root)
        status_frame.pack(fill=X, side=BOTTOM, pady=2)
        
        # Frame info (sinistra)
        info_frame = ttk.Frame(status_frame)
        info_frame.pack(side=LEFT, fill=X, expand=YES, padx=5)
        
        # Status label (in basso a sinistra)
        self.status_label = ttk.Label(info_frame, text="In attesa...", justify=LEFT)
        self.status_label.pack(side=LEFT, padx=5)
        
        # DateTime e User label (in basso a destra)
        ttk.Label(status_frame, textvariable=self.datetime_var).pack(side=RIGHT, padx=5)
        
        # Progress bar (sopra la barra di stato)
        progress_frame = ttk.Frame(self.root)
        progress_frame.pack(fill=X, side=BOTTOM, pady=(0, 2))
        
        self.progress_bar = ttk.Progressbar(progress_frame, mode='determinate', length=200)
        self.progress_bar.pack(fill=X, padx=5)
        
        # Aggiungi tooltip ai pulsanti principali
        self.create_tooltip(self.search_button, "Avvia la ricerca con i criteri specificati")
        self.create_tooltip(self.copy_button, "Copia i file selezionati nella directory specificata")
        self.create_tooltip(self.compress_button, "Comprimi i file selezionati in un archivio ZIP")
        

    # Avviso sulla spunta della ricerca dei contenuti
    def warn_content_search(self):
        """Mostra un avviso se l'utente attiva la ricerca nei contenuti"""
        if self.search_content.get():  # Se la checkbox è stata appena attivata
            messagebox.showwarning(
                "Attenzione", 
                "Attivando questa opzione rallenterà la ricerca e l'attesa sarà maggiore.",
                parent=self.root
            )
    def create_tooltip(self, widget, text, delay=500, fade=True):
        """Crea tooltip con ritardo, effetti di dissolvenza e larghezza automatica"""
        
        tooltip_timer = None
        fade_timer = None
        
        def show_tooltip():
            x = widget.winfo_rootx() + 25
            y = widget.winfo_rooty() + 25
            
            tooltip = ttk.Toplevel(widget)
            tooltip.wm_overrideredirect(True)
            tooltip.attributes("-alpha", 0.0)  # Inizia invisibile
            tooltip.attributes("-topmost", True)  # Mantiene sopra altre finestre
            
            # Crea un frame con bordo e padding
            frame = ttk.Frame(tooltip, borderwidth=1, relief="solid", padding=10)
            frame.pack(fill="both", expand=True)
            
            # Calcolo della larghezza del testo
            font = ("Segoe UI", 9)  # Puoi modificare questo per usare un altro font
            
            # Calcola la lunghezza approssimativa del testo
            import tkinter as tk
            temp_label = tk.Label(font=font)
            
            # Determina se il testo necessita di essere diviso in più righe
            lines = text.split("\n")
            max_line_width = 0
            
            for line in lines:
                temp_label.configure(text=line)
                line_width = temp_label.winfo_reqwidth()
                max_line_width = max(max_line_width, line_width)
            
            # Limita la larghezza massima a 500 pixel
            max_width = min(max_line_width, 500)
            
            # Se il testo è più corto della larghezza massima, non imposta wraplength
            # altrimenti imposta wraplength per dividere il testo in righe
            if max_line_width > 500:
                wraplength = 500
            else:
                wraplength = max_line_width
                
            # Crea l'etichetta con il testo
            label = ttk.Label(frame, text=text, justify="left", 
                            wraplength=wraplength, font=font)
            label.pack(fill="both", expand=True)
            
            # Distruggi il label temporaneo
            temp_label.destroy()
            
            # Aggiorna immediatamente per calcolare le dimensioni
            tooltip.update_idletasks()
            
            # Posiziona il tooltip in modo che non vada fuori dallo schermo
            tooltip_width = tooltip.winfo_reqwidth()
            tooltip_height = tooltip.winfo_reqheight()
            
            screen_width = tooltip.winfo_screenwidth()
            screen_height = tooltip.winfo_screenheight()
            
            # Aggiusta la posizione se il tooltip esce dallo schermo
            if x + tooltip_width > screen_width:
                x = screen_width - tooltip_width - 10
            
            if y + tooltip_height > screen_height:
                y = screen_height - tooltip_height - 10
                
            # Imposta la posizione finale
            tooltip.wm_geometry(f"+{x}+{y}")
            
            widget._tooltip = tooltip
            
            if fade:
                # Effetto dissolvenza in entrata
                def fade_in(alpha=0.0):
                    if not hasattr(widget, "_tooltip"):
                        return
                    
                    tooltip.attributes("-alpha", alpha)
                    if alpha < 1.0:
                        nonlocal fade_timer
                        fade_timer = widget.after(20, lambda: fade_in(alpha + 0.1))
                
                fade_in()
        
        def enter(event):
            nonlocal tooltip_timer
            # Avvia il timer per mostrare il tooltip dopo un certo ritardo
            tooltip_timer = widget.after(delay, show_tooltip)
        
        def leave(event):
            nonlocal tooltip_timer, fade_timer
            
            # Cancella il timer se esiste
            if tooltip_timer:
                widget.after_cancel(tooltip_timer)
                tooltip_timer = None
            
            # Cancella il timer di dissolvenza se esiste
            if fade_timer:
                widget.after_cancel(fade_timer)
                fade_timer = None
            
            # Rimuovi il tooltip se esiste
            if hasattr(widget, "_tooltip"):
                if fade:
                    # Effetto dissolvenza in uscita
                    def fade_out(alpha=1.0):
                        if alpha <= 0 or not hasattr(widget, "_tooltip"):
                            if hasattr(widget, "_tooltip"):
                                widget._tooltip.destroy()
                                del widget._tooltip
                        else:
                            widget._tooltip.attributes("-alpha", alpha)
                            nonlocal fade_timer
                            fade_timer = widget.after(20, lambda: fade_out(alpha - 0.1))
                    
                    fade_out()
                else:
                    widget._tooltip.destroy()
                    del widget._tooltip
        
        # Gestisce anche il caso in cui il widget venga distrutto
        def on_destroy(event):
            nonlocal tooltip_timer, fade_timer
            if tooltip_timer:
                widget.after_cancel(tooltip_timer)
            if fade_timer and hasattr(widget, "_tooltip"):
                widget.after_cancel(fade_timer)
                widget._tooltip.destroy()
        
        widget.bind("<Enter>", enter)
        widget.bind("<Leave>", leave)
        widget.bind("<Destroy>", on_destroy)
    def select_all(self):
        self.results_list.selection_set(self.results_list.get_children())
        
    def deselect_all(self):
        self.results_list.selection_remove(self.results_list.get_children())
        
    def invert_selection(self):
        all_items = self.results_list.get_children()
        selected_items = self.results_list.selection()
        self.results_list.selection_remove(selected_items)
        to_select = set(all_items) - set(selected_items)
        for item in to_select:
            self.results_list.selection_add(item)

    def compress_selected(self):
        selected_items = self.results_list.selection()
        if not selected_items:
            messagebox.showwarning("Attenzione", "Seleziona almeno un elemento da comprimere")
            return
            
        zip_name = Querybox.get_string(
            prompt="Inserisci il nome del file ZIP (senza estensione):",
            title="Nome file ZIP",
            initialvalue="archivio"
        )
        
        if not zip_name:
            return
            
        zip_path = filedialog.asksaveasfilename(
            defaultextension=".zip",
            initialfile=f"{zip_name}.zip",
            filetypes=[("ZIP files", "*.zip")],
            title="Salva file ZIP"
        )
        
        if not zip_path:
            return
                # Raccogli tutti i file delle cartelle selezionate
        files_in_folders = set()
        folder_paths = []
        single_files = []
        
        # Prima fase: raccogli informazioni su cartelle e file
        for item in selected_items:
            values = self.results_list.item(item)['values']
            item_type, match_type, source_path = values  # Ora ci sono 3 colonne
            
            if item_type == "Cartella":
                folder_paths.append(source_path)
                # Raccogli tutti i file nelle cartelle selezionate
                for root, _, files in os.walk(source_path):
                    for file in files:
                        full_path = os.path.join(root, file)
                        files_in_folders.add(os.path.abspath(full_path))
            else:
                single_files.append(source_path)
        
        # Filtra i file singoli che sono già presenti nelle cartelle
        filtered_single_files = [f for f in single_files if os.path.abspath(f) not in files_in_folders]
        
        total_items = len(folder_paths) + len(filtered_single_files)
        processed = 0
        
        try:
            with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                # Prima comprimi le cartelle
                for folder_path in folder_paths:
                    base_folder = os.path.basename(folder_path)
                    for root, _, files in os.walk(folder_path):
                        for file in files:
                            file_path = os.path.join(root, file)
                            # Mantieni la struttura delle cartelle nel zip
                            rel_path = os.path.relpath(file_path, os.path.dirname(folder_path))
                            zipf.write(file_path, rel_path)
                    
                    processed += 1
                    progress = (processed / total_items) * 100
                    self.progress_bar["value"] = progress
                    self.status_label["text"] = f"Compressi {processed} di {total_items} elementi"
                    self.root.update()
                
                # Poi comprimi i file singoli (solo quelli non già presenti nelle cartelle)
                for file_path in filtered_single_files:
                    if os.path.exists(file_path):  # Verifica che il file esista ancora
                        zipf.write(file_path, os.path.basename(file_path))
                        
                    processed += 1
                    progress = (processed / total_items) * 100
                    self.progress_bar["value"] = progress
                    self.status_label["text"] = f"Compressi {processed} di {total_items} elementi"
                    self.root.update()
            
            # Prepara il messaggio di completamento
            skipped_files = len(single_files) - len(filtered_single_files)
            message = f"Compressione completata!\nFile salvato in: {zip_path}"
            if skipped_files > 0:
                message += f"\n{skipped_files} file saltati perché già presenti nelle cartelle"
                
            messagebox.showinfo("Completato", message)
            
        except Exception as e:
            messagebox.showerror("Errore", f"Errore durante la compressione: {str(e)}")
            
        finally:
            self.progress_bar["value"] = 0
            self.status_label["text"] = "In attesa..."

    def copy_selected(self):
        selected_items = self.results_list.selection()
        if not selected_items:
            messagebox.showwarning("Attenzione", "Seleziona almeno un elemento da copiare")
            return
            
        dest_dir = filedialog.askdirectory(title="Seleziona directory di destinazione")
        if not dest_dir:
            return
            
        total_items = len(selected_items)
        copied = 0
        errors = 0
        
        for i, item in enumerate(selected_items):
            values = self.results_list.item(item)['values']
            item_type = values[0]
            source_path = values[5]  # Ora il percorso è nella sesta colonna
            
            try:
                dest_path = os.path.join(dest_dir, os.path.basename(source_path))
                
                if item_type == "File":
                    shutil.copy2(source_path, dest_path)
                else:  # Cartella
                    shutil.copytree(source_path, dest_path)
                copied += 1
                
            except Exception as e:
                errors += 1
                print(f"Errore durante la copia di {source_path}: {str(e)}")
            
            # Aggiorna la progress bar
            progress = ((i + 1) / total_items) * 100
            self.progress_bar["value"] = progress
            self.status_label["text"] = f"Copiati {i + 1} di {total_items} elementi"
            self.root.update()
                
        message = f"Copia completata.\nCopiati con successo: {copied}"
        if errors > 0:
            message += f"\nErrori: {errors}"
            
        self.status_label["text"] = "Copia completata"
        messagebox.showinfo("Completato", message)

    def search_files_and_folders(self):
        keywords = [k.strip().lower() for k in self.keywords.get().split()]
        self.search_results = []
        folders_results = []
        files_results = []
        
        processed_items = 0
        
        # Usa os.scandir invece di os.walk per migliori prestazioni
        def scan_directory(path, depth=0):
            nonlocal processed_items
            
            if self.max_depth > 0 and depth > self.max_depth:
                return
                
            try:
                with os.scandir(path) as entries:
                    for entry in entries:
                        if self.stop_search:
                            return
                            
                        try:
                            # Processa le directory
                            if entry.is_dir():
                                if self.search_folders.get() and any(keyword in entry.name.lower() for keyword in keywords):
                                    folders_results.append(("Cartella", entry.path))
                                
                                processed_items += 1
                                if processed_items % 100 == 0:  # Aggiorna il progresso meno frequentemente
                                    self.progress_queue.put(("status", f"Processati {processed_items} elementi"))
                                    
                                # Continua la scansione delle sottodirectory
                                scan_directory(entry.path, depth + 1)
                                
                            # Processa i file
                            elif entry.is_file() and self.search_files.get():
                                if any(keyword in entry.name.lower() for keyword in keywords):
                                    # Applica filtri avanzati se presenti
                                    if self.apply_advanced_filters(entry.path):
                                        files_results.append(("File", entry.path))
                                    
                                processed_items += 1
                                if processed_items % 100 == 0:
                                    self.progress_queue.put(("status", f"Processati {processed_items} elementi"))
                        except PermissionError:
                            # Gestisci errori di permesso con grazia
                            continue
            except PermissionError:
                # Gestisci errori di permesso per la directory
                pass
        
        # Avvia la scansione ricorsiva
        scan_directory(self.search_path.get())
                # Ordina i risultati
        folders_results.sort(key=lambda x: x[1].lower())
        files_results.sort(key=lambda x: x[1].lower())
        self.search_results = folders_results + files_results
        
        # Aggiorna la lista dei risultati
        self.root.after(0, self.update_results_list)
        
        # Segnala completamento
        self.progress_queue.put(("complete", None))
        
        if not self.search_results:
            self.root.after(0, lambda: messagebox.showinfo("Risultati", "Nessun risultato trovato"))

    def get_file_type(self, file_path):
        """Determina il tipo di file"""
        try:
            if os.path.isdir(file_path):
                return "Directory"
            
            # Ottieni l'estensione in minuscolo
            ext = os.path.splitext(file_path)[1].lower()
            
            # Mappa delle estensioni
            file_types = {
                # Documenti
                '.doc': 'Word Document',
                '.docx': 'Word Document',
                '.pdf': 'PDF Document',
                '.txt': 'Text Document',
                '.rtf': 'Rich Text Format',
                
                # Fogli di calcolo
                '.xls': 'Excel Workbook',
                '.xlsx': 'Excel Workbook',
                
                # Presentazioni
                '.ppt': 'PowerPoint Presentation',
                '.pptx': 'PowerPoint Presentation',
                
                # Immagini
                '.jpg': 'JPEG Image',
                '.jpeg': 'JPEG Image',
                '.png': 'PNG Image',
                '.gif': 'GIF Image',
                '.bmp': 'Bitmap Image',
                
                # Altri formati comuni
                '.zip': 'ZIP Archive',
                '.rar': 'RAR Archive',
                '.exe': 'Executable File',
                '.dll': 'Dynamic Link Library',
                
                # Aggiungi altri tipi di file secondo necessità
            }
            
            # Restituisce il tipo di file o un tipo generico se non trovato
            return file_types.get(ext, f'File{ext}' if ext else 'Unknown File')
        
        except Exception as e:
            print(f"Errore nel determinare il tipo di file per {file_path}: {str(e)}")
            return "Unknown File"

    def update_results_list(self):
        """Aggiorna la lista dei risultati"""
        # Pulisci la lista esistente
        for item in self.results_list.get_children():
            self.results_list.delete(item)
        
        # Inserisci i nuovi risultati
        if self.search_results:
            for result in self.search_results:
                try:
                    # Assicurati che il risultato sia un dizionario
                    if isinstance(result, dict):
                        values = (
                            result['type'],
                            result['match'],
                            result['size'],
                            result['modified'],
                            result['created'],
                            result['path']
                        )
                    else:  # Se è ancora nel vecchio formato tupla
                        _, match_type, size, modified, created, path = result
                        file_type = self.get_file_type(path)  # Ricalcola il tipo
                        values = (file_type, match_type, size, modified, created, path)
                    
                    self.results_list.insert("", "end", values=values)
                    print(f"Inserito risultato: {values[0]}")  # Debug
                    
                except Exception as e:
                    print(f"Errore nell'inserimento del risultato: {str(e)}")
                    continue
            
            self.status_label["text"] = f"Trovati {len(self.search_results)} elementi"
        else:
            self.results_list.insert("", "end", 
                values=("Info", "", "", "", "", "Nessun file trovato"))
            self.status_label["text"] = "Nessun file trovato per la ricerca effettuata"

    
    def apply_advanced_filters(self, file_path):
        """Controlla se un file corrisponde ai filtri avanzati"""
        try:
            # Debugging
            debug_prefix = f"[{os.path.basename(file_path)}]"
            
            # Filtro dimensione
            if self.advanced_filters["size_min"] > 0 or self.advanced_filters["size_max"] > 0:
                file_size = os.path.getsize(file_path)
                if self.advanced_filters["size_min"] > 0 and file_size < self.advanced_filters["size_min"]:
                    print(f"{debug_prefix} Filtrato: dimensione {file_size} < min {self.advanced_filters['size_min']}")
                    return False
                if self.advanced_filters["size_max"] > 0 and file_size > self.advanced_filters["size_max"]:
                    print(f"{debug_prefix} Filtrato: dimensione {file_size} > max {self.advanced_filters['size_max']}")
                    return False
            
            # Filtro data - VERSIONE DEBUG
            if self.advanced_filters["date_min"] or self.advanced_filters["date_max"]:
                try:
                    file_time = os.path.getmtime(file_path)
                    file_date = datetime.fromtimestamp(file_time)
                    file_date_only = file_date.replace(hour=0, minute=0, second=0, microsecond=0)
                    
                    print(f"{debug_prefix} Data file: {file_date.strftime('%d-%m-%Y')}")
                    
                    # Controlla data minima
                    if self.advanced_filters["date_min"] and self.advanced_filters["date_min"].strip():
                        try:
                            min_date = datetime.strptime(self.advanced_filters["date_min"], "%d-%m-%Y")
                            min_date = min_date.replace(hour=0, minute=0, second=0, microsecond=0)
                            print(f"{debug_prefix} Data minima: {min_date.strftime('%d-%m-%Y')}")
                            
                            if file_date_only < min_date:
                                print(f"{debug_prefix} FILTRATO: Data file {file_date_only} < min {min_date}")
                                return False
                        except ValueError as e:
                            print(f"{debug_prefix} Errore nel formato della data minima: {e}")
                    
                    # Controlla data massima
                    if self.advanced_filters["date_max"] and self.advanced_filters["date_max"].strip():
                        try:
                            max_date = datetime.strptime(self.advanced_filters["date_max"], "%d-%m-%Y")
                            max_date = max_date.replace(hour=23, minute=59, second=59, microsecond=999999)
                            print(f"{debug_prefix} Data massima: {max_date.strftime('%d-%m-%Y')}")
                            
                            if file_date_only > max_date:
                                print(f"{debug_prefix} FILTRATO: Data file {file_date_only} > max {max_date}")
                                return False
                        except ValueError as e:
                            print(f"{debug_prefix} Errore nel formato della data massima: {e}")
                
                except Exception as e:
                    print(f"{debug_prefix} Errore generale nel filtro data: {str(e)}")
                    # In caso di errore con le date, non filtrare questo file per essere conservativi
            
            # Filtro estensione
            if self.advanced_filters["extensions"]:
                _, ext = os.path.splitext(file_path)
                ext_lower = ext.lower()
                extensions_lower = [e.lower() for e in self.advanced_filters["extensions"]]
                if ext_lower not in extensions_lower:
                    print(f"{debug_prefix} Filtrato: estensione {ext_lower} non in {extensions_lower}")
                    return False
            
            # Se arriva qui, il file è passato attraverso tutti i filtri
            return True
        except Exception as e:
            print(f"Errore nei filtri avanzati per {os.path.basename(file_path)}: {str(e)}")
            return True  # In caso di errore generale, include il file (più conservativo)
    
    def safe_file_operation(self, operation_func, source_path, dest_path, item_type):
        """Esegui un'operazione su file in modo sicuro con gestione degli errori appropriata"""
        try:
            if os.path.exists(dest_path):
                response = messagebox.askyesnocancel(
                    "File già esistente",
                    f"'{os.path.basename(dest_path)}' esiste già.\n"
                    "Vuoi sovrascrivere il file?",
                    icon="warning"
                )
                
                if response is None:  # Annulla
                    return False, "Operazione annullata"
                elif not response:  # No
                    return False, "File saltato"
            
            # Esegui l'operazione
            operation_func(source_path, dest_path)
            return True, ""
            
        except PermissionError:
            return False, "Errore di permessi"
        except FileNotFoundError:
            return False, "File non trovato"
        except shutil.Error as e:
            return False, f"Errore di copia: {str(e)}"
        except Exception as e:
            return False, f"Errore: {str(e)}"
        # Punto di ingresso dell'applicazione
    def run_search(self):
        """Avvia la ricerca con i parametri specificati"""
        # Pulisci i risultati precedenti
        self.search_results = []
        
        # Ottieni i parametri di ricerca
        search_path = self.path_entry.get()
        search_keywords = self.keyword_entry.get()
        
        # Se nessun percorso è specificato, usa il percorso corrente
        if not search_path:
            search_path = os.getcwd()
        
        # Verifica che il percorso esista
        if not os.path.exists(search_path):
            self.status_label["text"] = f"Errore: Il percorso '{search_path}' non esiste"
            return
        
        # Suddividi le parole chiave in termini separati
        search_terms = [term.strip() for term in search_keywords.split(',') if term.strip()]
        
        # Avvia la ricerca in un thread separato per non bloccare l'UI
        self.disable_ui()
        self.status_label["text"] = "Ricerca in corso..."
        self.status_bar.update_idletasks()
        
        threading.Thread(target=self._search_thread, args=(search_path, search_terms)).start()
        
    def get_file_metadata(self, file_path):
        """Estrae i metadati dal file specificato"""
        try:
            # Ottiene le statistiche del file
            file_stat = os.stat(file_path)
            
            # Calcola la dimensione del file in formato leggibile
            size_bytes = file_stat.st_size
            if size_bytes < 1024:
                size_str = f"{size_bytes} B"
            elif size_bytes < 1024 * 1024:
                size_str = f"{size_bytes / 1024:.1f} KB"
            elif size_bytes < 1024 * 1024 * 1024:
                size_str = f"{size_bytes / (1024 * 1024):.1f} MB"
            else:
                size_str = f"{size_bytes / (1024 * 1024 * 1024):.2f} GB"
            
            # Ottiene le date di modifica e creazione nel formato DD-MM-YYYY HH:MM
            mod_time = datetime.fromtimestamp(file_stat.st_mtime).strftime('%Y-%m-%d %H:%M:%S')
            
            # In Windows st_ctime è la data di creazione, in Unix è la data di cambio stato
            if os.name == 'nt':  # Windows
                create_time = datetime.fromtimestamp(file_stat.st_ctime).strftime('%Y-%m-%d %H:%M:%S')
            else:  # Unix/Linux/Mac
                create_time = datetime.fromtimestamp(file_stat.st_atime).strftime('%Y-%m-%d %H:%M:%S')
            
            return {
                "size": size_str,
                "modified": mod_time,
                "created": create_time
            }
        except Exception as e:
            print(f"Errore nell'estrazione dei metadati per {file_path}: {e}")
            return {
                "size": "N/A",
                "modified": "N/A", 
                "created": "N/A"
            }

    def update_current_datetime(self):
        """Aggiorna le informazioni di data/ora correnti"""
        current_time = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')
        formatted_text = (
            f"Current Date and Time (UTC): {current_time}\n"
            f"Current User: {self.user_var.get()}"
        )
        self.datetime_var.set(formatted_text)
        
        # Aggiorna ogni secondo
        self.root.after(1000, self.update_current_datetime)

    def _search_thread(self, search_path, search_terms, search_content):
        """Thread principale di ricerca"""
        try:
            items_processed = 0
            files_checked = 0
            files_filtered = 0
            total_items_estimated = 500
            self.search_results = []  # Pulisci i risultati precedenti
            
            def recursive_search(current_path, depth=0):
                nonlocal items_processed, files_checked, files_filtered
                
                if self.stop_search:
                    return
                    
                try:
                    with os.scandir(current_path) as entries:
                        for entry in entries:
                            if self.stop_search:
                                return
                                
                            items_processed += 1
                            if items_processed % 10 == 0:
                                progress = min(int((items_processed / total_items_estimated) * 100), 100)
                                self.progress_queue.put(("progress", progress))
                                self.progress_queue.put(("status", 
                                    f"Processati {items_processed} elementi ({files_checked} file verificati, {files_filtered} filtrati)"))
                            
                            # Gestione file
                            if entry.is_file():
                                if not self.apply_advanced_filters(entry.path):
                                    files_filtered += 1
                                    continue
                                
                                file_type = self.get_file_type(entry.path)  # Ottieni il tipo di file
                                
                                # Cerca nei nomi dei file
                                if self.search_files.get() and any(term.lower() in entry.name.lower() for term in search_terms):
                                    metadata = self.get_file_metadata(entry.path)
                                    
                                    result = {
                                        'type': file_type,
                                        'match': 'Nome',
                                        'size': metadata['size'],
                                        'modified': metadata['modified'],
                                        'created': metadata['created'],
                                        'path': entry.path
                                    }
                                    self.search_results.append(result)
                                    print(f"File trovato: {entry.name} - Tipo: {file_type}")  # Debug
                                
                                # Cerca nei contenuti
                                if search_content and self.is_text_file(entry.path):
                                    files_checked += 1
                                    try:
                                        content = self.extract_text_from_file(entry.path).lower()
                                        if any(term.lower() in content for term in search_terms):
                                            metadata = self.get_file_metadata(entry.path)
                                            
                                            result = {
                                                'type': file_type,
                                                'match': 'Contenuto',
                                                'size': metadata['size'],
                                                'modified': metadata['modified'],
                                                'created': metadata['created'],
                                                'path': entry.path
                                            }
                                            self.search_results.append(result)
                                            print(f"Contenuto trovato in: {entry.name} - Tipo: {file_type}")  # Debug
                                    except Exception as e:
                                        print(f"Errore lettura contenuto: {entry.path} - {str(e)}")
                            
                            # Gestione directory
                            elif entry.is_dir():
                                if self.search_folders.get() and any(term.lower() in entry.name.lower() for term in search_terms):
                                    metadata = self.get_file_metadata(entry.path)
                                    
                                    result = {
                                        'type': 'Directory',
                                        'match': '',
                                        'size': metadata['size'],
                                        'modified': metadata['modified'],
                                        'created': metadata['created'],
                                        'path': entry.path
                                    }
                                    self.search_results.append(result)
                                    print(f"Directory trovata: {entry.name}")  # Debug
                                
                                if self.max_depth == 0 or depth < self.max_depth:
                                    recursive_search(entry.path, depth + 1)
                                
                except PermissionError:
                    print(f"Permesso negato: {current_path}")
                except Exception as e:
                    print(f"Errore in {current_path}: {str(e)}")
            
            # Avvia la ricerca
            recursive_search(search_path)
            
        except Exception as e:
            error_message = f"Errore durante la ricerca: {str(e)}"
            print(error_message)
            traceback.print_exc()
            self.progress_queue.put(("error", error_message))
        finally:
            if not self.stop_search:
                self.progress_queue.put(("complete", None))

    def search_files_in_path(self, current_path, search_terms, current_depth=0, max_depth=0):
        """Cerca file e cartelle nel percorso specificato e nelle sottocartelle"""
        
        # Controlla se dobbiamo rispettare un limite di profondità
        if max_depth > 0 and current_depth > max_depth:
            return
        
        try:
            # Ottieni la lista di tutti i file e cartelle
            items = os.listdir(current_path)
            
            for item in items:
                # Ignora i file nascosti se richiesto
                if self.ignore_hidden.get() and item.startswith('.'):
                    continue
                    
                full_path = os.path.join(current_path, item)
                
                # Gestione file
                if os.path.isfile(full_path):
                    # Cerca nei nomi dei file
                    if self.search_files.get() and self.match_pattern(item, search_terms):
                        self.search_results.append(("File", "Nome", full_path))
                        print(f"Trovato file (nome): {full_path}")
                    
                    # Cerca nei contenuti dei file - IMPORTANTE: usa "if" invece di "elif"
                    if self.search_content.get():
                        print(f"Provo a cercare nei contenuti di: {full_path}")
                        # Verifica prima se è un file di testo
                        if self.is_text_file(full_path):
                            try:
                                print(f"Leggendo il file: {full_path}")
                                with open(full_path, 'r', encoding='utf-8', errors='ignore') as f:
                                    content = f.read().lower()
                                    # Cerca tutte le parole chiave nel contenuto
                                    for term in search_terms:
                                        if term.lower() in content:
                                            self.search_results.append(("File", "Contenuto", full_path))
                                            print(f"Trovato file (contenuto): {full_path}")
                                            break  # Esci dal ciclo una volta trovata una corrispondenza
                            except Exception as e:
                                print(f"Errore nella lettura del file {full_path}: {e}")
                        else:
                            print(f"File non di testo: {full_path}")
                
                # Gestione cartelle
                elif os.path.isdir(full_path):
                    # Cerca nei nomi delle cartelle
                    if self.search_folders.get() and self.match_pattern(item, search_terms):
                        self.search_results.append(("Cartella", "", full_path))
                        print(f"Trovata cartella: {full_path}")
                    
                    # Cerca nelle sottocartelle (ricorsione)
                    self.search_files_in_path(full_path, search_terms, current_depth + 1, max_depth)
                    
        except Exception as e:
            print(f"Errore nel percorso {current_path}: {str(e)}")
            
    def match_pattern(self, file_name, search_terms):
        """Verifica se il nome del file corrisponde ai termini di ricerca"""
        file_name_lower = file_name.lower()
        for term in search_terms:
            if term.lower() in file_name_lower:
                return True
        return False
    
    def is_text_file(self, file_path):
        """Verifica se un file è probabilmente un file di testo leggibile o un documento supportato"""
        # Ignora i file temporanei di Office
        if os.path.basename(file_path).startswith("~$"):
            return False
            
        # Verifica l'estensione del file
        ext = os.path.splitext(file_path)[1].lower()
        
        # File di Office comuni
        office_extensions = [
            '.docx', '.doc',   # Word
            '.xlsx', '.xls',   # Excel
            '.pptx', '.ppt',   # PowerPoint
            '.odt', '.ods', '.odp',  # OpenDocument
            '.rtf',            # Rich Text Format
            '.pdf'             # PDF
        ]
        
        # Debug esplicito per i file Office
        if ext in office_extensions:
            print(f"✓ File Office trovato: {file_path} - Tipo: {ext}")
            return True
        
        # Evita file troppo grandi (più di 10MB)
        try:
            if os.path.getsize(file_path) > 10 * 1024 * 1024:  # Limite 10 MB
                return False
        except:
            return False
            
        # Estensioni comuni di file di testo o documenti supportati
        text_extensions = ['.txt', '.py', '.java', '.c', '.cpp', '.h', '.html', '.css', '.js', '.json', '.xml', '.md', 
                        '.log', '.csv', '.ini', '.cfg', '.config', '.bat', '.sh', '.ps1', '.tex', '.sql']
        
        if ext in text_extensions:
            return True
        
        # Per file senza estensione, prova a leggere i primi byte
        if not ext:
            try:
                with open(file_path, 'rb') as f:
                    sample = f.read(1024)
                    # Verifica che sia un file di testo (ASCII o UTF-8)
                    return all(c < 127 for c in sample if c != 0)
            except:
                return False
        
        return False

    def extract_text_from_file(self, file_path):
        """Estrae il testo da vari tipi di file"""
        # Ignora i file temporanei di Office
        if os.path.basename(file_path).startswith("~$"):
            return ""
                
        ext = os.path.splitext(file_path)[1].lower()
        print(f"Estraendo testo da: {file_path} (tipo: {ext})")
        
        try:
            # File Word (.docx, .doc)
            if ext == '.docx' and file_format_support["docx"]:
                try:
                    doc = docx.Document(file_path)
                    return '\n'.join([paragraph.text for paragraph in doc.paragraphs])
                except Exception as e:
                    print(f"Errore nell'estrazione del testo da file Word {file_path}: {e}")
                    return ""
            
            # File OpenDocument (.odt, .ods, .odp)
            elif ext in ['.odt', '.ods', '.odp'] and file_format_support["odt"]:
                try:
                    if 'odfdo' in globals():
                        doc = odfdo.Document(file_path)
                        body = doc.body
                        all_text = body.get_formatted_text()
                        print(f"Testo estratto con odfdo: {len(all_text)} caratteri")
                        return all_text
                    
                    elif 'opendocument' in dir():
                        doc = opendocument.load(file_path)
                        all_paragraphs = []
                        for paragraph in doc.getElementsByType(text.P):
                            all_paragraphs.append(teletype.extractText(paragraph))
                        result = '\n'.join(all_paragraphs)
                        print(f"Testo estratto con odf: {len(result)} caratteri")
                        return result
                    
                    # Metodo alternativo usando zipfile
                    else:
                        return self._extract_from_zip(file_path, 'content.xml')
                except Exception as e:
                    print(f"Errore nell'estrazione del testo da file OpenDocument {file_path}: {e}")
                    return self._extract_from_zip(file_path, 'content.xml')
            
            # File Excel (.xlsx, .xls)
            elif ext in ['.xlsx', '.xls'] and file_format_support["excel"]:
                try:
                    workbook = openpyxl.load_workbook(file_path, read_only=True, data_only=True)
                    text_content = []
                    for sheet_name in workbook.sheetnames:
                        sheet = workbook[sheet_name]
                        for row in sheet.rows:
                            row_text = [str(cell.value) if cell.value is not None else '' for cell in row]
                            text_content.append(' '.join(row_text))
                    return '\n'.join(text_content)
                except Exception as e:
                    print(f"Errore nell'estrazione del testo da file Excel {file_path}: {e}")
                    return ""
            
            # File PowerPoint (.pptx, .ppt)
            elif ext in ['.pptx', '.ppt'] and file_format_support["pptx"]:
                try:
                    presentation = pptx.Presentation(file_path)
                    text_content = []
                    for slide in presentation.slides:
                        for shape in slide.shapes:
                            if hasattr(shape, "text"):
                                text_content.append(shape.text)
                    return '\n'.join(text_content)
                except Exception as e:
                    print(f"Errore nell'estrazione del testo da file PowerPoint {file_path}: {e}")
                    return ""
            
            # File PDF
            elif ext == '.pdf' and file_format_support["pdf"]:
                try:
                    with open(file_path, 'rb') as f:
                        reader = PyPDF2.PdfReader(f)
                        text_content = []
                        for page_num in range(len(reader.pages)):
                            text_content.append(reader.pages[page_num].extract_text())
                    return '\n'.join(text_content)
                except Exception as e:
                    print(f"Errore nell'estrazione del testo da file PDF {file_path}: {e}")
                    return ""
            
            # File RTF
            elif ext == '.rtf' and file_format_support["rtf"]:
                try:
                    with open(file_path, 'r', errors='ignore') as f:
                        rtf_content = f.read()
                    return rtf_to_text(rtf_content)
                except Exception as e:
                    print(f"Errore nell'estrazione del testo da file RTF {file_path}: {e}")
                    return ""
            
            # File di testo normali
            else:
                try:
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        return f.read()
                except Exception as e:
                    print(f"Errore nella lettura del file di testo {file_path}: {e}")
                    return ""
        except Exception as e:
            print(f"Errore generale nell'estrazione del testo da {file_path}: {e}")
            return ""
    
def _extract_from_zip(self, file_path, internal_file):
    """Estrae un file da un archivio zip (usato per OpenDocument)"""
    try:
        import zipfile
        import re
        
        with zipfile.ZipFile(file_path) as z:
            if internal_file in z.namelist():
                with z.open(internal_file) as f:
                    content = f.read().decode('utf-8')
                    # Rimuovi i tag XML per ottenere solo il testo
                    text_only = re.sub(r'<[^>]+>', ' ', content)
                    print(f"Testo estratto con zipfile da {internal_file}: {len(text_only)} caratteri")
                    return text_only
            return ""
    except Exception as e:
        print(f"Errore nell'estrazione da ZIP {file_path}: {e}")
        return ""
        
def main():
    root = ttk.Window(themename="darkly")
    app = FileSearchApp(root)
    
    # Imposta l'icona dell'applicazione se disponibile
    try:
        icon_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "icon.ico")
        if os.path.exists(icon_path):
            root.iconbitmap(icon_path)
    except:
        pass
    
    # Centra la finestra sullo schermo
    root.update_idletasks()
    width = root.winfo_width()
    height = root.winfo_height()
    x = (root.winfo_screenwidth() // 2) - (width // 2)
    y = (root.winfo_screenheight() // 2) - (height // 2)
    root.geometry('{}x{}+{}+{}'.format(width, height, x, y))
    
    # Imposta data e ora attuali, username
    current_datetime = "2025-03-07 22:05:10"
    username = "Antonino"
    
    # Aggiorna la barra di stato con data/ora e username
    app.datetime_var.set(f"Data: {current_datetime} | Utente: {username}")
    
    root.mainloop()

if __name__ == "__main__":
    main()
